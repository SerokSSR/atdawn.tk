{"meta":{"title":"小林书架","subtitle":"","description":"Creator & OIer","author":"","url":"https://snow.js.org","root":"/"},"pages":[{"title":"","date":"2021-01-19T03:52:34.118Z","updated":"2021-01-19T03:52:34.118Z","comments":true,"path":"twik.css","permalink":"https://snow.js.org/twik.css","excerpt":"","text":"/* build time:Tue Jan 19 2021 21:48:53 GMT+0800 (GMT+08:00)*/ .tk-extras{display:none!important}.tk-content{margin-top:0!important} /* rebuild by hrmmi */"},{"title":"AS FOR ME","date":"2021-01-19T03:11:29.448Z","updated":"2021-01-19T03:11:29.448Z","comments":true,"path":"about/index.html","permalink":"https://snow.js.org/about/","excerpt":"","text":"游戏热爱者 创作者 OIer | NOIP2020 AFO 2022 高考 现居天津 | 来自天津 | 咸鱼批发公司 | 学生"},{"title":"留言板","date":"2021-01-19T13:46:50.001Z","updated":"2021-01-19T13:46:50.001Z","comments":true,"path":"board/index.html","permalink":"https://snow.js.org/board/","excerpt":"","text":".tk-submit { margin-top: 1.2rem !important; } .tk-extras { display: none !important; } .tk-comment { margin-top: 0rem !important; } .tk-content { margin-top: 0rem !important; } .tk-footer { display: none !important; } # Here twikoo.init({ envId: 'twikoo-4g5mwk3u17573ee8', el: '#tcomment', // region: 'ap-guangzhou', // 环境地域，默认为 ap-shanghai，如果您的环境地域不是上海，需传此参数 // path: 'window.location.pathname', // 用于区分不同文章的自定义 js 路径，如果您的文章路径不是 location.pathname，需传此参数 })"},{"title":"分类","date":"2021-01-19T03:11:28.211Z","updated":"2021-01-19T03:11:28.211Z","comments":true,"path":"categories/index.html","permalink":"https://snow.js.org/categories/","excerpt":"","text":""},{"title":"友链清理记录","date":"2021-01-19T03:11:26.809Z","updated":"2021-01-19T03:11:26.809Z","comments":true,"path":"errors/index.html","permalink":"https://snow.js.org/errors/","excerpt":"","text":"友链被对方单向删除：安河桥北以北 bx%%%g.cn；纵饮孤独 z%% d.site； 网站无法访问：保温杯的小站 fu%%%%%ye.ga； 博客文章抄袭：笔记 b%%%te.cn；"},{"title":"友人帐","date":"2021-01-19T13:47:13.829Z","updated":"2021-01-19T13:47:13.829Z","comments":true,"path":"friends/index.html","permalink":"https://snow.js.org/friends/","excerpt":"","text":"# OIers SerokSSR 九死南荒吾不恨，兹游奇绝冠平生 SiRiehn_nx 从开始的连名带姓到最后的连名带姓 SingerCoder In solitude, where we are least alone. # 樂特全球後援會 沉默的小嘉 好记性不如烂笔头 Lete 乐特 我相信我可以，但我一直在路上，所以我有无限的可能！！ 小康博客 一个收藏回忆与分享技术的地方！ 百般美好 山有扶苏，隰有荷华 卓越科技 Remarkable life, for science and technology. # 友人帐 YlovexLN 井底之蛙，虽不知大海之宽阔，却知晓天空之蓝！ Heo 爱折腾的设计师 阿俊 🤪🤪🤪 Nescx 青石落晚巷 故人未还乡 Sitoi 活到老，学到老 大白萝卜 一只爱吃兔子的萝卜🥕 HelloWorld 不知道呢┑(￣Д ￣)┍ 栖枝 perch 用心创造设计，改变生活 Kylin 学习不易，努力努力~ Colsrch 愿多年以后，我可以酌一杯清酒，烂醉如泥，梦中回到我们的曾经。 ConstOwn 能与你一起成长，我荣幸之至。 DmxZ 欢迎来到 DmxZ 的自留地！ Flexiston 立即行动吧，未来要自己争取 PluShine XJHui's Blog # 友人帐 幕光倾城 钝学累功，勤能补拙 Aurora's 偷偷厉害 万物尽可期待！ 煎鱼的海 人之帅，莫过于煎鱼 圣文のblog 学深夜的习，读清晨的书 Sakura` Blogs 或苦或甜都不要辜负 ZEHAN 没有撤退可盐！ 忧郁的派大星 越学习，越发现自己的无知 hfzvictory 深自缄默，如云漂泊 Qing Sheng 努力的小白 王稻草 就是很喜欢啊 曦秋的小屋 西交的学术小垃圾 M-GX 在头秃的路上越走越远~ # 我的信息 site: Seekerurl: https://snow.js.org/image: https://cdn.jsdelivr.net/gh/SerokSSR/cdn/share.jpgdesc: 九死南荒吾不恨，兹游奇绝冠平生 交换友链请先添加本站，并按如下格式在留言板留言。 不定期检查友链。如果被误清理，请重新申请。 site 站点名称 必填 owner 管理员名字 可选，默认为 site 的值 url 站点链接 必填 desc 站点描述 可选，默认为 url 的值 image 站点图标 可选，默认为 images/404.png color 鼠标悬停时链接块颜色 可选，默认为 #666"},{"title":"乐特全球后援会","date":"2021-01-19T00:44:12.002Z","updated":"2021-01-19T00:44:12.002Z","comments":true,"path":"lete/index.html","permalink":"https://snow.js.org/lete/","excerpt":"","text":"# 加入我们 （小）康（乐）特全球后援会 QQ 群：939534493 # 后援活动"},{"title":"留言板","date":"2021-01-19T03:06:15.907Z","updated":"2021-01-19T03:06:15.907Z","comments":true,"path":"messageboard-copy/index.html","permalink":"https://snow.js.org/messageboard-copy/","excerpt":"","text":"来自 Chtholly 的留言 こんなにも、たくさんの幸せをあの人に分けてもらった だから、きっと 今の、私は 誰が何と言おうと 世界一、幸せな女の子だ 来自 Chtholly 的留言 こんなにも、たくさんの幸せをあの人に分けてもらった だから、きっと 今の、私は 誰が何と言おうと 世界一、幸せな女の子だ"},{"title":"标签","date":"2021-01-19T03:11:30.720Z","updated":"2021-01-19T03:11:30.720Z","comments":true,"path":"tags/index.html","permalink":"https://snow.js.org/tags/","excerpt":"","text":""}],"posts":[{"title":"NOIP2020 游记","slug":"NOIP2020 游记","date":"2020-12-04T16:00:00.000Z","updated":"2021-01-19T00:42:42.088Z","comments":true,"path":"noip2020-you-ji/","link":"","permalink":"https://snow.js.org/noip2020-you-ji/","excerpt":"","text":"高二 OIer @SerokSSR，坐标 TJ。 退役了。 # Once upon a time 大概是 NOI Online 刚开始的时候吧，就想着该为 1= 做准备了。三场全都参加了，第一次忘写头文件，第二次抽屉原理不会，第三次才将将苟进了全国前 25%。 说实话是挺沮丧的，当时觉得省一没戏了，但是还是想努力一把。 # Summer 暑假报了 luogu 网课。之前一直没系统学过 DP，结果看提纲发现 DP 直接从状压开始讲，于是从 0 开始恶补了好一阵子，但是还是写不出方程来。 网校讲到后面的课基本上都听不大懂了，记得数论听了一半就去睡觉了。 要了基础组的深基，边补基础边学背包，暑假基本就这么过去了。 开学打算把竞赛暂时放一放，因为其实不太想报 -OH，只是想在退役前圆一个省一梦。 # CSP-S1 第一个月过去了，基本上是每周末如果作业写完了就写几道题，如果作业太多就咕掉。 去考初赛，以前一直是有分就行，所以没啥压力。 选择题似乎比较水很快做完了，然后看程序，一看这不是昨天 luogu 刚出的 nth_element，瞎分析了一波复杂度全写上了。 被 O(n)O(n)O(n) 的 map 笑到了，但是题还是不会做。搞了一阵子发现是宽搜，怎么搜的还是看不懂。选项全是蒙的。 最后一个 DP 也没看懂，随便选了几个长得好看的写上了。 出来估分 60~70，听母上大人说有个小孩出来高兴地说太简单了 我：??? 最终得分 83，成了 rank4 可惜初赛分无一点用，复赛还是一道题不会做。 今年复赛考点换成 nk，初赛线都划到 44 了，有点可啪。 之后渐渐就是能不写的作业都不写了，每周末基本上两个整天都在学 OI。 # CSP-S2 和期中考试正好在同一周。Singercoder 直接把期中咕掉了，我想了想自己的 OI 水平，还是参加了，不过除了物理生物基本都没咋复习。上午考完，回家就对着电脑坐一下午。 听说过了一轮就可以去考 NOIP，所以也没特意准备。第二天上午背了背 Tarjan 板子，直接去考试了。 开场一看 T1 是个大模拟，觉得自己的码力问题不大（，就开始写 结果写了两个小时，1600 年之后还是一年一年跳的。过了大样例。结果跟脑子短路了一样，不开 T2 开始想 T1 优化。。。 然后就一直调不对了。 最后一小时扔掉调不出来的 T1 想 T2，草草读完题，互不相同也没注意到。O(k×2k)O(k\\times 2^k)O(k×2k) 走人。 赛后出考场估分 80+40+20+0，以为还可以。 晚上 luogu 自测，发现 T1 年份边界全写挂了，T3 还没取模，T4 白送的 20 分暴力也没写。 当时就流眼泪了，捂着眼，我说停停。 脚造大样例，问候出题人。 周一浑浑噩噩地去上课。mrc 劝我赶快停课，我想了想确实，但是还是等一会吧。 心态快崩了，不过倒是没崩。 # 停课 期中出分了，班级 rank3，年级在 rank5 左右。 可是人总是想得到没得到的东西的。 找杨鸽签了假条，周五正式开始停课。当时是 11.27，离 NOIP2020 还有刚好两周。 之后的日子也不清楚是怎么过来的。刷历年的题、写总结、写题解看题解，一天一天就这么过去了。 开始喜欢听古风歌了。耳机单曲了好一阵子的 风筝误 和 不见长安。 他还陷在那段隔世经年的梦 静静和衣睡去 不理朝夕 CSP 出分了，10+40+10+0=60 rank36，省三第一。已经有心理准备了，心情没太波动。 # NOIP-1 图书馆真的安静，Singercoder 和 zach0914 都不说话。 中午去踢球，后防被对面特长生冲烂了。 看了一天的 DP 题和题解，快放学的时候才知道期望的定义 回家把做过的题往脑子里塞，看到大概 8:00 左右。 然后开始看 KPL，想着 DYG 一定要赢啊。结果眼睛是看着比赛，脑子里想了很多乱七八糟的，紧张的要死。 打到 3:2 的时候十点多了，去睡觉。 一晚上没睡好。 # NOIP 早晨看了眼微博，DYG 4:2 AG，心情略微好了一点。 在门口集合的工夫和 zach0914 和 lth 说了说话。lth 掏出了刘汝佳开始看。 过了一会儿 Singercoder 也到了，一起进去。进考场看见了 SiRiehn_nx（当时还叫 zhltao），听他 fAKe 了几句。 CSP 的时候显示屏糊的要死，这回终于换了。 一坐在座位上反倒不那么紧张了，想着尽力就好吧。骑车来的，虽然有戴手套，不过还是冻僵了。 8:30 开考。T1 一看拓扑板子直接开始敲，手有点僵硬，而且中间有一段时间怎么也过不去样例，很慌，几乎把中间变量全输出了一遍，发现是次序写反了。然后大样例又没过。随手把 int 换成了 long long 竟然过了，当时感觉这题稳了。信心很足。用时 35min。 看 T2，觉得 NOIP 不可能考 KMP 的（，所以想怎么 DP。想不出来，上来开始大力模拟，敲了 30min 左右过了前两个样例，第三个本机跑了 2s，问题有点大。 打算把字母全相等的点先放一放，去看 T3。暴力都没有一点思路，想着 T4 估计会更难，必须得把这个的部分分拿下来。然后还是没有思路。 只好去看 T4，读题就读了好久。显然是我不可做的题，直接上爆搜，感觉细节不是一般的多，就没敲，回去把 T2 的相等情况写了。直接拿暴力改的，觉得没问题就没对拍。又看了一会儿 T3，还是没思路。 觉得必须得开 T4 了。枚举好像就很麻烦，最后用了一个递归生成状态，然后开了个 map&lt;vector&lt;int&gt;, vector&lt;int&gt; &gt; 判无解…… 看前两个样例都过了，就这样吧。现在一想感觉自己是个 zz，为啥不状压一下啊。 很快就中午了，感觉有点饿。忽然想到 T2 可以前缀和优化一点点，写上发现第三个点直接降到了 0.2s，这回应该很稳了吧。当时估了一下分，100+56+0+10，因为 T1 直接是板子觉得这回不太行，又去想 T3。 一想不管了，直接把暴力敲上。敲了 100 多行一运行直接爆栈了，一看只有半个多小时了，干脆全删了打了个随机数，开始检查。 剩 20 多分钟的时候发现 T2 的相等做法 WA 了…… 调了十分钟没调出来，横下心不管了。然后就一遍一遍地查 freopen 和路径。 考完一个一个去前面核对程序，结果我是我们考场倒数第二个。出来的时候，其他考场已经都走光了。当时脑子里就全是空白的，想着这样也挺好，千万不要听到别人讨论做法。 nk 校园确实比某数字中学好看一万倍 考前一周，jzx 在给下一届的放 KMP 讲解视频。 我：这东西根本不用会吧 QAQ，NOIP 一辈子没考过 考试前一天，我们一群人在图书馆口胡押题。 我：拓扑 CSP 刚考完啊，也不会再考第二遍了吧 开过光的嘴。。。 忍不住上 luogu 看了看，看见第一题 1~m 的时候整个人都不好了。后来看见 CZ 说不卡这个又活了过来。高精卡不卡就无所谓了。 oitiku 90+48+0+30，测了一圈似乎都比我分高 /fad 很慌。 洛谷和 oitiku 的分一样。看了看讨论区，1= 应该是稳了吧 /qaq。不知道蓝勾有没有。 心情挺复杂的。明明已经完成目标圆满退役了，却总觉得少了点什么，心里空荡荡的，似乎既有不甘，又有不舍。OI 真的就像划过黑暗的流星，闪着荧烁的火光，可消失却只需短短一瞬。你甚至来不及准备。 我看着自己的排名，又无可救药地动起了心思，尽管理智告诉我希望渺茫。我想着该让自己冷静冷静了，于是打开电脑，写了这么一篇游记。 # Future 周围的人和我自己都在告诉我，说你应该认清自己，比起冲队，whk 才是更优解吧，无论是从性价比还是从实力。话是这么说，距离将它接受成现实可能还需要一段时间了。 最后祝我自己好运，祝 rsx (SiRiehn_nx)、lgh (Singercoder)、zsh (tyslsiZ) RP++, AK IOI. 谨以此文纪念我的 OI 生涯。 T1 出题人的双亲大概是溘然长逝了吧，连交换律都卡。90-&gt;60。靠这个做区分度是我没想到的。 60+48+0+30 = 138，弱省 rank10，无缘蓝勾。 就这样吧。 初中的直接从榜上消失了？CCF 属实迷惑操作，让人家参加结果连成绩证明都不给。 这 1= 线真的离谱...... 最终 rank7，以最后一名的成绩苟到了 1=。 怎么感觉要进队了（ 等等我好像比基准线高了？？？那岂不是说...... 果然。 TJ 分到了七个省队名额，而七个 1= 被数字中学和 nk 包揽了；因为我比基准线高，所以执行三分之一限制。也就是说有两个省二能进队；而我和 rsx 如果想进队，必须要考到自己学校的第二名。rsx 有一点点希望，而且他是高一，还有无限的可能。 而我...... 得知消息的那天晚上，刚好作业不多。我对着手机，坐了一整晚。 这大概是我离 Cu 最近的一次了。可我刚要反应过来，它却早已裂成了碎片。 成为了 TJ 近十年来第一个被校杀的选手。还要继续努力！ 后来想了想，我确实完全没有在 NOI 拿到 100+ 的能力。A 过最难的题是绿题（其他的不是板子就是教练带着做的），DP 和图上问题考场上永远是只会敲暴力。今年的题但凡阳间一点，可能就要复刻去年的结局了。就算侥幸进了队，也要押上半个高考，去赌一个渺茫的未来。 从 2018 年暑假入坑，到现在两年多了，可水平似乎从 18 年的普及开始就在原地踏步。只是多会了一些算法，犯病的概率减少了一些。见到带点思维难度的就直接投降。至今没有打过一场 CF。 还是不够强罢了。 甘心吗？当然不甘心。为什么这套题才考了一百分的就能进队，而我却没有了机会。难道这就是所谓的公平吗，whk 成绩越低越好？确实，即使没有校杀，最后的结局很可能也没有什么变化，可我仍然希望做出选择的人是自己。尽管可能他们才是对的吧。 可又能怎样呢。 都结束了吧。 高考加油。","categories":[{"name":"小说 & 随笔","slug":"hitokoto","permalink":"https://snow.js.org/categories/hitokoto/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://snow.js.org/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"数论：不定方程整数解","slug":"数论：扩展欧几里得","date":"2020-11-22T16:00:00.000Z","updated":"2021-01-19T00:42:42.357Z","comments":true,"path":"num-exgcd/","link":"","permalink":"https://snow.js.org/num-exgcd/","excerpt":"","text":"# 扩展欧几里得 求不定 ax+by=cax+by=cax+by=c 的所有整数解。 # 判断该方程是否有解 裴蜀定理：设 gcd⁡(a,b)=d\\gcd(a, b) = dgcd(a,b)=d，则对任意整数 x, y，有 d|(ax + by) 成立； 特别地，一定存在 x, y 满足 ax + by = d 等价的表述：不定方程 ax + by = c (a, b, c 为整数) 有解的充要条件为 (a, b)|c 推论：a, b 互质等价于 ax + by = 1 有解 因此只要求出 ax+by=gcd⁡(a,b)ax+by=\\gcd(a,b)ax+by=gcd(a,b) 的解，然后扩倍（乘上 [c][d]\\frac[c][d]c[​][d]）即可。 # 求出任意一个解 考虑使用欧几里德算法的思想，令 a = bq + r，其中 r = a mod b； 递归求出 bx + ry = d 的一个解。 设求出 bx + ry = d 的一个解为 x = x0, y = y0，考虑如何把它变形成 ax + by = d 的解。 将 a = bq + r 代入 ax + by = d，化简得 b (xq + y) + rx = d 我们令 xq + y = x0, x = y0，则上式成立 故 x = y0, y = x0 - y0q 为 ax + by = d 的解 注意边界情况：当 b=0b = 0b=0 时，此时 a=gcd⁡(a,b)=da = \\gcd(a,b) = da=gcd(a,b)=d，因此令 x=1,y=0x = 1, y = 0x=1,y=0 即可。 # 怎么求 ax+by=dax + by = dax+by=d 的所有解？ 先用 exgcd 求出任意一个解 x = x0, y = y0 再求出 ax + by = 0 的最小的解 x = dx = b/(a, b), y = dy = -a/(a, b) 所有解就是 x = x0 + kdx, y = y0 + kdy, k 取任意整数 # NOIP2017 D1T1 小凯的疑惑 有一个比较好理解的扩欧做法 已知题目必存在答案，那么设 k−1k-1k−1 为答案，则 ax+by=kax+by=kax+by=k 必有一组非负整数解 (x,y)(x,y)(x,y) 假设 ax+by=k−1ax+by=k-1ax+by=k−1 有非负整数解，那么该式必能化为 a(x−x0)+b(y−y0)=ka(x-x_0)+b(y-y_0)=k a(x−x0​)+b(y−y0​)=k 其中 ax0+by0=1ax_0+by_0=1 ax0​+by0​=1 注意到，若尽量使该式能够有解，则有两种情况，分别令 x0x_0x0​ 或 y0y_0y0​ 取其最小非负整数解 x′x&#x27;x′ 和 y′′y&#x27;&#x27;y′′（因为一方最小时另一方必为最大情况） 因此为了让原式无解，需保证 x−x′&lt;0,y−y′′&lt;0x-x&#x27;&lt;0, y-y&#x27;&#x27;&lt;0x−x′&lt;0,y−y′′&lt;0，即 x&lt;x′,y&lt;y′′x&lt;x&#x27;,y&lt;y&#x27;&#x27;x&lt;x′,y&lt;y′′ 因为要构造最大非负整数解，所以令 x=x′−1,y=y′′−1x=x&#x27;-1,y=y&#x27;&#x27;-1x=x′−1,y=y′′−1 所得即为 kkk，答案即为 a(x′−1)+b(y′′−1)−1a(x&#x27;-1)+b(y&#x27;&#x27;-1)-1a(x′−1)+b(y′′−1)−1。 到这就可以结束了，不过其实还能进一步化简 有一个很显然的结论，ax0+by0=1ax_0+by_0=1ax0​+by0​=1 是没有非负整数解的 把 x,yx,yx,y 想象成分别在两个竖直的数轴上，可以发现，对于上面的两组解 (x′,y′)(x&#x27;,y&#x27;)(x′,y′)、(x′′,y′′)(x&#x27;&#x27;,y&#x27;&#x27;)(x′′,y′′)，他们都是离水平面（原点）最近的解，所以他们在扩欧通解上是相邻的 则 y′′=y′+ay&#x27;&#x27;=y&#x27;+ay′′=y′+a，原式 a(x′−1)+b(y′′−1)−1a(x&#x27;-1)+b(y&#x27;&#x27;-1)-1 a(x′−1)+b(y′′−1)−1 =ax′−a+by′′−b−1=ax&#x27;-a+by&#x27;&#x27;-b-1 =ax′−a+by′′−b−1 =ax′+by′+ab−a−b−1=ax&#x27;+by&#x27;+ab-a-b-1 =ax′+by′+ab−a−b−1 =ab−a−b.=ab-a-b. =ab−a−b.","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://snow.js.org/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"图论：LCA","slug":"图论：LCA","date":"2020-11-20T16:00:00.000Z","updated":"2021-01-19T00:42:42.358Z","comments":true,"path":"graph-lca/","link":"","permalink":"https://snow.js.org/graph-lca/","excerpt":"","text":"# LCA: Lowest common ancestor 最近公共祖先 # 倍增求 LCA 预处理向上跳 2^k 步的结果 f [k][x] O(nlog⁡n)O(n \\log n)O(nlogn) 求的时候先把两个点跳到一个深度，这里有一个特判，如果重合直接返回这个点 然后 log 值从大往小枚举，两个点一起不断向上跳，直至父亲相同，直接返回父节点 可以O(n)O(n)O(n) 预处理 log 值，把复杂度降到 O(常数)O(常数)O(常数) # 欧拉序求 LCA 欧拉序：dfs 时的访问完整路径，回溯时也要把这个点算上 易知欧拉序的长度是 2n-1，从边的角度考虑，每条边都是来回访问了两次，加上根节点的初始访问，2 (n-1)+1=2n-1 这里就是一个小性质，记 p [i] 为 i 节点在欧拉序中第一次出现的位置，则对任意的 u,v，在 ol [p [u]..p [v]] 段内，使 p [ol [i]] 最小的 ol [i] 即为 lca (u,v) 多次询问可用 ST 表预处理最小值 O(nlog⁡n)O(n \\log n)O(nlogn) 预处理，O(1)O(1)O(1) 查询 （刚发现我的 ST 表之前一直带 log 查询的。。。 # Tarjan 求 LCA # 树剖求 LCA","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://snow.js.org/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"LCA","slug":"lca","permalink":"https://snow.js.org/tags/lca/"}]},{"title":"凝眉（第一稿）","slug":"凝眉","date":"2020-11-07T16:00:00.000Z","updated":"2021-01-19T00:42:42.086Z","comments":true,"path":"ning-mei/","link":"","permalink":"https://snow.js.org/ning-mei/","excerpt":"","text":"p{text-indent: 32px;} # 凝眉 他和她走下车。站台上熙熙攘攘的人守望在那里。没有人向他们看上一眼。 他们停下脚步，看着列车消失在金色的反光里，只留下无底的空白。 “所以…… 新见和五反田他们呢？” 高桥问道。 “他们？他们不会来了。” 他想了想道。“他们还到不了这里。” 她点了点头。 “走吧。” 他握住她的手。 他们费力地拨开人群。等他惊觉的时候，那只手已经松开了。他张望着伸长了脖子，似乎想在人海中辨出她的身影，却像极了在水中捞月的猿。 出得车站，迎面便是阵阵狂风。雪浪排空，秋云怒卷。眼见得风越来越大，他跑向公交站，赶上了去往营口道的车。街上行人寥寥，许是都躲进路旁的小店了吧。 离码头不远的地方，他看到了一个女孩，头发披散在肩上，斜挎着包，朝着风来临的方向走去。他只是瞥了她一眼，很快就失去了兴致，目光投向前面的世纪钟和几幢小楼。 高桥匆匆地走着，不安地环顾着周遭的一切。她大致知道这是什么地方了。风卷着沙砾扫过，不舍昼夜。她略略低下头，眼中只有脚下的路。 他闭上眼，眼前突然又浮出她的音容。他抿起嘴，知道这里没有白来。他一定能遇见她。 地铁站门口的长椅上，一个穿着校服的男孩倒在那里。不断地，有的人指指点点，有的人掏出手机，更多的人就擦身而过，目不斜视，珂珮丁当。自然便有了慨叹的人了，曰世风浇漓云云，三岁贯女，莫我肯顾。 救护车很快赶到了。几个人没等停稳就跳下了车，确认那个男孩还活着，便麻利将他收拾好，三下五除二地抬了上去。车呜呜叫着开走了。 他甚至有些感伤：眼前喳喳的人群很快也会如潮散去。这里便什么也不会留下了吧。 他走近长椅，看到了卡在木缝里的几枚纸团。他逐一展开看了看，又小心翼翼地叠好，收进了背包里。他平静地做好了这一切，可当他抬起头，眼中却已被血丝蒙络。 他带着悄怆的神采投向远方，却只能看见平平的楼宇，早已洇成了褐黄的墙皮，掩映在树丛的胸膛下。 他捡起地上散落的酒瓶，正要往嘴里灌，又哐地摔碎到了地上。水流像蛇一样沿着砖缝汩汩爬去，留下属于他的未来。 他跌跌撞撞地起身远去。尽管深一脚浅一脚地走着，他的足迹却惊人地笔直，就像大地在随着他的步履而偏移。 雾开始落下来，虚化着前路。 他偷偷走到她的身后，一把蒙住了她的眼。她象征性地挣扎了几下。他很快松开手，向后退了几步，眼里映满了她的影子。 “还是找到这里了啊，” 他笑着说。 她白了他一眼。 “下楼走走吧。” 他揽住她的腰；他们走下楼去。皎皎清光透过楼梯侧的窗，洒进空无一人的走廊里，散着幽沁的香。 他和她坐在跑道边，说是要等着，等最后一片云霞沉寂在地平线下。时不时地，他们凑在对方的耳边，轻声低语；欢谑声里，沉沉的烟火灿烂着，像雪染成的白绫。风打在他和她的肩上。 那片云明明随风飘摇着，却迟迟没有离去。月亮不息地转动着。缓缓地，他和她之间像是有些什么，成片成片地生长着，拣尽寒枝。 像一束一束的光。 果然还是偏离了啊，他无声叹道。错过了那一瞬，就算过后再怎么努力，就算你已拥有了一切，你如履薄冰，你不敢高声语，你尽力维护着原样的展览馆。殊不知时间没有负半轴。你再也回不到从前。 他闭上眼。那时他想了太多，他不知道孰对孰错，他不着边际地猜着，就这样过去了。后来他迷途知返，却已无路可退。 “今天…… 月亮好好看。” 他睁开眼，看看天，又看看她。她也望向天空，微蹙眉头，显得有些诧异，大概是没有感到什么分别吧，只是一湾再普通不过的月亮，撒着空灵的光。 她不着痕迹地点了点头。 他的目光没有移开。她怔了怔，略略偏过头，唇角勾起一个弧度，又回过头正视着他。 远处传来一声巨响。 他回过神，目光却始终没有从她的脸移开。她的眼里似乎闪过了一道意味难明的神采来。他没有看清，可即便他看清的话，他也一定会以为那盈盈秋水里，映着的是他自己的影子。 一如她方才的浅笑，一落在他的眼里，便似料峭雪峰陡然塌落，绽起了明媚的飞光。 贪、嗔、痴、怨，爱别离，求不得。 世界的走向尽管去变吧，他想。连过去都错过了，还谈什么未来呢。 他已经无路可退。 他堵住了她的唇。接下来的事已经从这个世界上抹去了，他试着撕开那层薄纱，也终究只能看到未来的投影。两个人滚在一起。一朵血梅葳蕤绽放。 生生繁华于枯荑，萋萋空翠自灵犀。辉星皓夜苍千顷，此宵风醉月舞萤。 他迷迷糊糊地醒了过来，在一片花海里。满川的红叶簌簌飘落，尽是离人眼中血；他拼了命想要醒来，却像陷在了无垠的沼泽。他只好回到梦中，描绘了她的远去，宛若降兮北渚的帝子。后来他才发现，原来是梦里有个小人拦在他的面前，死命拽住了他的脚，怎么也不愿意长大。 他离开了那个地方，却不知是怎么做到的。一如来时。她早已不在他身旁。他觉得很可笑，明明是亲手缔结的世界，却如同活在梦中。 他原以为能找回他失去的东西的。可他反倒又丢失了好多；她和他的一部分永远地遗失在了那里，遗失在了那个无法企及的角落。他的脑中一片空白，任由身躯驱使他穿过影影绰绰的人群，已分辨不出哪个是她，哪个是熟悉的陌生人。就连残存的记忆，也被那一部分所吸引着，渐渐从他的意识里剥离。他说不上来自己究竟后不后悔，也许是不吧；他攥着唯一的烛火，走遍了无数的 occasion，上穷碧落下黄泉。现在烛火也最后熄灭了。或许也是新的开始呢，他想。他拖着疲惫的身躯登上了来时的列车；随着车向前，一寸一寸的大地像是耗尽了最后的力量，轰然坍落，正如他刚刚所见的，沼底尽头的宫殿。一点一点的萤火在空中翻飞，散化为繁星点点，连同他的碎片，连同他和她的一切，连同那最后一丝烙印。他最后一次忆起她的身影，茕茕然在那里，迎上他的目光，嫣然一笑，胜过一切盛放的花。窗外像是有什么在呼啸着：他试图回想起，却早已飘散如烟。他不清楚何时何地，抑或是每时每地也未可知。阳光贪婪地闯了进来，不放过每一处罅隙，洒在她莹莹的脸上。她抿起唇。他倏地站起，眼中却已被水雾弥漫。 远处，站台已隐约可见。他探出车窗，像是要看些什么，却终于没有看清。他毁掉了他的一切，风却照旧着来临。 他沿着来时的路走去。路旁的烧烤摊上，他看见了新见、五反田、三谷，和其他几个人聚在一起，畅谈着过去，也畅谈着未来。 他们看见他的到来像是很惊讶。新见从隔壁桌又搬来一把凳子。他们团团围着坐了。 “你一个人回来的？高桥呢？” 新见开口问道。 “高桥是谁？” 他问。 “没事了，” 新见道。“记错人了。” “哦。” 他没再说话，抓起烤串啃了起来。其他人也恢复了先前的样子，觥筹交错，起坐喧哗。 “还是要回沼底去吗？” 五反田问道。 “是啊。” “沼底…… 和以前不太一样了。” 三谷道。 “哦。” “这是…… 在威胁我吗？” 他擦了擦额头，问道。出人意料地，新见点了点头。 “算是吧。不过你要是执意回去…… 我们不拦着你。” 新见又拿了一串烤鱿鱼，“还是那句话，我们是真心在劝你。” “心领了，” 他略一拱手。 “又是有非去不可的理由呵……” 新见向后仰去。工藤擤了擤鼻子。 他们对视了一会。 “一直向那边走…… 走到头右拐。沼底就在那里。” 半晌，新见像是放弃了努力。“注意安全。路上不再像以前那样了。” “好。” 夜很快就深了。他们相对无言。 他站起身。 “希望这不是最后一次见面吧。” 上原举起酒杯，微笑致意。他也笑着回礼。 “那么…… 再会。” 他背上书包。 “再会，” 他们齐声道。 他匆匆地走了。他知道，身后那群人在向他挥手目送，却一定不能回头。 路旁的景致从原野过到了黑白。他不知所措地望着前方，像是看到了那隙天边的裂痕，一针刺下便能渗出殷红的血。 他不断回想着刚才的会面，其中一定有他忘记了的东西。一张张面孔纤毫毕现，如在目前，像老式的放映机吱吱作响。他们倒是相信着未来，可最终却不是失去了自己的名字，就是去往了另一个世界。 他惊醒过来，发现自己已经站在路的终点了。前面是一堵砖墙，并不够高，却足以屏蔽他的目光。他在路口踌躇了许久，近乎能猜出墙后的场景了。那里只有最纯粹的白天与黑暗，只有最清白的绝望与梦想，只有最纷乱的花雨与黄沙。 可他还是收回了心思，径直向右走去。另一个方向上，几个外国人举着摄像机，叽里咕噜地说着什么。章老师不断点头回应着，又重新扛起了金箍棒，周而复始。汗水浸湿了他的猴毛假发。 到那边先去找鲲吧，他想。他一定会带我去找他们的。还有 C 和 Betsy…… 他们究竟走到了哪里？他们的时间又在何处停止？他们能不能触及心底的奢望？他们…… 我放下笔起身。远处，天塔像是响应着节约的号召，灭尽了全部的光亮，徒留名姓载孤舟；可年年相望的月亮却好像觉悟不高的样子，仍旧卖力地将别人施予的光又施予给每一个角落，照出了掩映的层云。广寒悠悠，遗世独立，羽化而登仙。 我坐回书桌，对着摊了整整一桌的草稿，却迟迟无法下笔。我想到笔下的一个个人物，他们在各自的旅途上孤独地跋涉着，却一直希冀着能够邂逅另外的一半，愿前路交织在一起。他们有的孑然一身，却并不孤独；可更多的纵是莺莺燕燕，孤独却已渗入骨髓。不过至少他们都以相同的方式来到了终点吧，无论孤独与否。他们本都有无限的可能。 我在纸张间左右横跳，眼前似乎看到了那位主人公，孤独地走在沼底的路上。其实…… 他已经消失在了他毁掉的那个地方吧。他终是要和五反田他们一起，就像 1944 年东京的住民，分不清哪一个会最终降临。想到这，我不禁笑了起来，眼里噙满了泪花。 高桥几个留在了沼底的尽头；章老师留在了中美合拍的现场；C 和 Betsy 留在了一个又一个的迷宫：人人都有光辉的未来吧，又或许人人都没有了未来。白骨如山忘姓氏，无非公子与红妆。 我合上手稿，想起还有两个月就要退役了。我关灯躺在床上，沉沉睡去，梦中看见了初生的朝阳，携着金色的流光，照亮了无边的黑暗。 （完）","categories":[{"name":"小说 & 随笔","slug":"hitokoto","permalink":"https://snow.js.org/categories/hitokoto/"},{"name":"未来","slug":"hitokoto/future","permalink":"https://snow.js.org/categories/hitokoto/future/"}],"tags":[{"name":"小说","slug":"小说","permalink":"https://snow.js.org/tags/%E5%B0%8F%E8%AF%B4/"}]},{"title":"年轻人不讲武德","slug":"武德","date":"2020-11-05T16:00:00.000Z","updated":"2021-01-19T11:27:24.432Z","comments":true,"path":"mabaoguo/","link":"","permalink":"https://snow.js.org/mabaoguo/","excerpt":"","text":"# 缘起 # 健身房的年轻后生不讲武德偷袭马老师，把马保国老师的眼睛给蹭了一下 啊朋友们好啊，我是浑元形意太极门掌门人马保国。 刚才有个朋友，问我马老师发生甚么事了，我说怎么回事，给我发了几张截图。我一看，嗷，原来是左天，有两个年轻人，30 多岁，一个体重 90 多公斤，一个体重 80 多公斤。塔们说，诶，有一个说是，我在健身房练功，颈椎练坏了，马老师你能不能教教我浑元功法，矮… 帮助治疗一下我的颈椎病。我说可以。 我说你在健身房练死劲儿，不好用，塔不服气。诶，我说小朋友，你两个手来折我一个手指头，塔折不动，他说你这没用，我说我这个有用，这是化劲儿。传统功夫是讲化劲儿的，四两拨千斤。二百多斤的英国大力士都握不动我的一个手指头，啊。他非跟我试试，我说可以。 诶，我一说，他啪就站起来了。很快啊！然后上来就是一个左正蹬，一个右鞭腿，一个左刺拳，我全部防出防出去了啊。防出去以后，自然就是，传统功夫以点到为止。右拳放到他鼻子上没打他，我笑一下准备收拳，因为这时间，按传统功夫的点到为止，他已经输了。如果这一拳发力，一拳就把他鼻子打鸪鹧了。放在鼻子上没有打他，他也承认，我先打到他面部。他不知道拳放在了鼻子上，他承认我先打到他面部，啊！我收拳的时间不打了，他突然袭击，左刺拳来打我脸，啊。我大 E 了啊，没有闪。矮… 他的左拳给我眼，啊右眼，蹭了一下。但没关系啊，他也说，啊，他截图也说了，两分多钟以后，当时流眼泪了，捂着眼，我说婷婷，然后两分钟钟以后，两分多钟以后，诶… 就好了。 我说小伙子你不讲武德，你不懂。马老师对不起对不起我不懂规矩，啊，他说他是乱打的。他可不是乱打的啊，蹬蹬，鞭腿，左刺拳，训练有素。后来他说他练过三四年泰拳，啊，看来是有备而来！这两个年轻人不讲武德，来，骗，来，偷袭，我 69 岁的老同志。这好吗？这不好。我劝这位年轻人耗子尾汁，好好反思，以后不要再犯这样的聪明，小聪明，啊，呃… 武林要以和为贵，要讲武德，不要搞窝里斗。谢谢朋友们！ # 后续 一些已经搜不到的视频。 # 一 武 林 高 手 从白鼠这里火起来的。疑似是 B 站在推。 # 二 中 华 武 德 台词混剪。 # 三 马和耗子（完整版） # 四 马保国 × 王者荣耀：国服蒙恬 国服婉儿 # 五 8848 “耗子尾汁” 手机 # 六 ⚡吉 祥 三 马⚡ 联动。 # 七 比三鞭更强！马保国的松活弹抖闪电五连鞭！ 原片。 # 收尾","categories":[],"tags":[]},{"title":"图论：Tarjan","slug":"图论：Tarjan","date":"2020-11-04T16:00:00.000Z","updated":"2021-01-19T00:42:42.358Z","comments":true,"path":"graph-tarjan/","link":"","permalink":"https://snow.js.org/graph-tarjan/","excerpt":"","text":"# 前置概念 时间戳：搜索时第几个搜索到这个点。如搜索顺序是 1-&gt;2-&gt;3-&gt;6，则 6 的时间戳为 4 # 对于无向图 连通分量：对于图 G 来的一个子图中，任意两个点都可以彼此到达，这个子图就被称为图 G 的连通分量（一个点就是最小的连通分量） 最大连通分量：对于图 G 的一个子图，这个子图为图 G 的连通分量，且是图 G 所有连通分量中包含节点数最多的那个，即为 G 的最大联通分量 # 算法流程 个人认为 Tarjan 是提高组范围内最难的一个算法了，我自己说不太明白。。。推荐看看这篇 # 简单应用 # 缩点 有向图强连通分量：在有向图 G 中，如果两个顶点 vi,vj 间（vi&gt;vj）有一条从 vi 到 vj 的有向路径，同时还有一条从 vj 到 vi 的有向路径，则称两个顶点强连通 (strongly connected)。孤立的一个点也是一个强连通分量。 如果有向图 G 的每两个顶点都强连通，称 G 是一个强连通图。有向图的极大强连通子图，称为强连通分量（SCC, Strongly Connected Components）。把每个强联通分量看成一个集合，把每个集合看成一个点，那么所有 SCC 就形成了一个 DAG（有向无环图），就是著名的缩点。 Problem 根据题目意思，我们只需要找出一条点权最大的路径就行了，不限制点的个数。那么考虑对于一个环上的点被选择了，一整条环是不是应该都被选择，这一定很优，能选干嘛不选。很关键的是题目还允许我们重复经过某条边或者某个点，我们就不需要考虑其他了。因此整个环实际上可以看成一个点（选了其中一个点就应该选其他的点） 在处理了环后，我们就重新建立一张图，以每个环为节点（孤立一个点也算也算环的，其实也就是强联通分量了）。在这张图中我们要 dp，显然对于任意边 &lt;u,v&gt;， dp[v] = max(dp[v], dp[u] + new_weight[v]) 。 dp 的时候拓扑排一下序，这也是 DAGdp 的常见 trick 了。 #include &lt;bits/stdc++.h>using namespace std;const int N = 1e4+10, M = 1e5+10;struct node &#123; int u, v, nxt;&#125; e[M];int h[N], tot = 0;int dfn[N], low[N], tag = 0, top = 0, num = 0;int n, m, w[N], ww[N], f[N], id[N], s[N], in[N];void tarjan(int u) &#123; dfn[u] = low[u] = ++tag; s[++top] = u; for(int i = h[u], v; i; i = e[i].nxt) &#123; v = e[i].v; if(!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if(!id[v]) low[u] = min(low[u], dfn[v]); &#125; if(dfn[u] == low[u]) &#123; ++num; while(s[top] != u) &#123; id[s[top]] = num; ww[num] += w[s[top]]; top--; &#125; id[s[top]] = num; ww[num] += w[s[top]]; top--; &#125; &#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) scanf(\"%d\", w+i); for(int i=1; i&lt;=m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); if(u == v) continue; e[++tot] = &#123;u, v, h[u]&#125;; h[u] = tot; &#125; for(int i=1; i&lt;=n; ++i) &#123; if(!dfn[i]) tarjan(i); &#125; memset(h, 0, sizeof h); for(int i=0, t=0; i&lt;tot; ++i) &#123; int u = id[e[i].u], v = id[e[i].v]; if(u == v); else &#123; e[++t] = &#123;u, v, h[u]&#125;; h[u] = t; ++in[v]; &#125; &#125; queue&lt;int> q; for(int i=1; i&lt;=num; ++i) &#123; if(!in[i]) q.push(i); &#125; int ans = 0; for(int i=1; i&lt;=num; ++i) f[i] = ww[i], ans = max(ans, f[i]); while(!q.empty()) &#123; int u = q.front(); q.pop(); for(int i = h[u]; i; i = e[i].nxt) &#123; int v = e[i].v; f[v] = max(f[v], f[u]+ww[v]); ans = max(ans, f[v]); --in[v]; if(!in[v]) q.push(v); &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125;# 找割点 割点：去掉无向联通图的某个点后，此图不连通，该点为割点。 Problem #include &lt;stdio.h>#include &lt;iostream>using std::min;const int N = 22000, M = 110000;struct node &#123; int u, v, next;&#125; e[M &lt;&lt; 1];int h[N], tot;int dfn[N], low[N], tag;int res[N], ans, n, m, fa[N];void tarjan(int u, int fa) &#123; dfn[u] = low[u] = ++tag; int sum = 0; for(int i = h[u], v; i; i = e[i].next) &#123; v = e[i].v; if(v == fa) continue; if(dfn[v]) low[u] = min(low[u], dfn[v]); else &#123; ++sum; tarjan(v, u); low[u] = min(low[u], low[v]); if(fa == -1) continue; if(low[v] >= dfn[u]) res[u] = true; &#125; &#125; if(fa == -1 and sum > 1) res[u] = true; &#125;int main() &#123; //freopen(\"p3388_4.in\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;m); for(int i=1, x, y; i&lt;=m; ++i) &#123; scanf(\"%d%d\", &amp;x, &amp;y); e[++tot] = (node) &#123;x, y, h[x]&#125;; h[x] = tot; e[++tot] = (node) &#123;y, x, h[y]&#125;; h[y] = tot; &#125; for(int i=1; i&lt;=n; ++i) if(dfn[i] == 0) tarjan(i, -1); for(int i=1; i&lt;=n; ++i) if(res[i]) ++ans; printf(\"%d\\n\", ans); for(int i=1; i&lt;=n; ++i) if(res[i]) printf(\"%d \", i); return 0;&#125;","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://snow.js.org/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"DAG","slug":"dag","permalink":"https://snow.js.org/tags/dag/"}]},{"title":"简单动态规划：LIS、LCS、背包","slug":"简单动态规划：LIS、LCS、背包","date":"2020-10-31T16:00:00.000Z","updated":"2021-01-19T00:42:42.357Z","comments":true,"path":"dp-linear/","link":"","permalink":"https://snow.js.org/dp-linear/","excerpt":"","text":"# P1020 导弹拦截 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;algorithm>using namespace std;const int N = 100010;int n = 0;int a[N], b[N], s[N], ls[N];void add(int x, int v) &#123; for(; x&lt;=n; x+=x&amp;(-x)) s[x] = max(s[x], v); &#125;int query(int x) &#123; int ans = 0; for(; x>0; x-=x&amp;(-x)) ans = max(ans, s[x]); return ans;&#125;int main() &#123; //freopen(\"p1020_1.in\", \"r\", stdin); for(; scanf(\"%d\", a+n+1) != EOF; ++n, b[n] = a[n]); sort(b+1, b+n+1); int t = unique(b+1, b+n+1) - (b+1); for(int i=1; i&lt;=n; ++i) a[i] = lower_bound(b+1, b+t+1, a[i]) - b; int ans = 0; for(int i=n; i>0; --i) &#123; int q = query(a[i]) + 1; add(a[i], q); ans = max(ans, q); &#125; printf(\"%d\\n\", ans); ans = 0; memset(s, 0, sizeof s); for(int i=1; i&lt;=n; ++i) &#123; int q = query(a[i]-1) + 1; add(a[i], q); ans = max(ans, q); &#125; printf(\"%d\\n\", ans); return 0;&#125;# P1439 【模板】最长公共子序列 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;const int N = 100010;int n, b[N], p1[N], p2[N], s[N];int lowbit(int x) &#123; return x&amp;(-x);&#125;void add(int x, int v) &#123; for(; x &lt;= n; x += lowbit(x)) s[x] = max(s[x], v);&#125;int query(int x) &#123; int ans = 0; for(; x > 0; x -= lowbit(x)) ans = max(ans, s[x]); return ans;&#125;int main() &#123; scanf(\"%d\", &amp;n); for(int i=1; i&lt;=n; ++i) scanf(\"%d\", p1+i); for(int i=1; i&lt;=n; ++i) scanf(\"%d\", p2+i); for(int i=1; i&lt;=n; ++i) b[p1[i]] = i; for(int i=1; i&lt;=n; ++i) p2[i] = b[p2[i]]; int ans = 0; for(int i=1; i&lt;=n; ++i) &#123; int q = query(p2[i]-1) + 1; add(p2[i], q); ans = max(ans, q); &#125; printf(\"%d\", ans); return 0;&#125;# P5665 [CSP-S-2019] 划分 DP 思路：先固定一个在后面的点，然后通过枚举前面的点来求答案。 感觉好像很好想，又好像很难想到…… 不知道考场上会不会想到，总觉得大概率不会吧。 分析了一下去年的题目，100+35+10+24+24+0=193100+35+10+24+24+0=193100+35+10+24+24+0=193 的裸暴力分，去年已经是足够 1 = 了 不过今年限制只有高中的能参赛了。。。感觉压力好大 不管了，努力吧 #include &lt;bits/stdc++.h>using namespace std;const int N = 550000;typedef long long LL;LL ans = 0, a[N], s[N], last[N], dp[N];int n, type;int main() &#123; // freopen(\"partition.in\", \"r\", stdin);// freopen(\"partition.out\", \"w\", stdout); scanf(\"%d%d\", &amp;n, &amp;type); if(type == 0) &#123; for(int i=1; i&lt;=n; ++i) scanf(\"%lld\", a+i); for(int i=1; i&lt;=n; ++i) s[i] = s[i-1] + a[i]; memset(dp, 0x3f, sizeof dp); dp[0] = 0; //dp[1] = s[1] * s[1]; last[1] = s[1]; for(int i=1; i&lt;=n; ++i) &#123; for(int j=0; j&lt;i; ++j) &#123; if(s[i] - s[j] >= last[j] and dp[i] > dp[j] + (s[i]-s[j])*(s[i]-s[j])) &#123; dp[i] = dp[j] + (s[i]-s[j])*(s[i]-s[j]); last[i] = s[i] - s[j]; &#125; &#125; &#125; printf(\"%lld\\n\", dp[n]); &#125; else printf(\"4972194419293431240859891640\\n\"); return 0;&#125;# 0-1 背包 F(i,j)={F(i−1,j)j≤wimax⁡{F(i−1,j),F(i−1,j−wi)+vi}j&gt;wiF(i,j)= \\begin{cases} F(i-1,j)&amp; j \\leq w_i\\\\ \\max\\{F(i-1,j),F(i-1,j-w_i)+v_i\\}&amp; j &gt; w_i \\end{cases} F(i,j)={F(i−1,j)max{F(i−1,j),F(i−1,j−wi​)+vi​}​j≤wi​j&gt;wi​​ 注意二维转换成一维的时候，jjj 要从后向前枚举，因为每次的新结果都是根据上一个结果来求得的，从后向前可避免重复取同一物品。 # P2196 挖地雷 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;vector>using namespace std;const int N = 30;typedef pair &lt;int, vector&lt;int> > piv;vector&lt;int> g[N]; int s1[N], n, w[N], in[N];vector&lt;int> ss[N];piv ans;void outp(vector&lt;int> &amp;ans) &#123; for(vector&lt;int>::iterator it = ans.begin(); it != ans.end(); ++it) printf(\"%d \", *it); printf(\"\\n\");&#125;piv dfs(int x, vector&lt;int> s) &#123; if(s1[x]) &#123; return (piv)&#123;s1[x], ss[x]&#125;; &#125; if(g[x].size() == 0) &#123; s1[x] = w[x]; ss[x].clear(); ss[x].push_back(x); return (piv)&#123;s1[x], ss[x]&#125;; &#125; s1[x] = w[x]; ss[x].push_back(x); vector&lt;int> st = ss[x]; for(vector&lt;int>::iterator it = g[x].begin(); it != g[x].end(); ++it) &#123; piv p = dfs(*it, s); if(p.first + w[x] > s1[x]) &#123; s1[x] = p.first + w[x]; ss[x] = st; ss[x].insert(ss[x].end(), p.second.begin(), p.second.end()); &#125; &#125; return (piv)&#123;s1[x], ss[x]&#125;;&#125;int main() &#123; scanf(\"%d\", &amp;n); for(int i=1; i&lt;=n; ++i) scanf(\"%d\", w+i); for(int i=1, a; i&lt;=n; ++i) &#123; for(int j=i+1; j&lt;=n; ++j) &#123; scanf(\"%d\", &amp;a); if(a) g[i].push_back(j), ++in[j]; &#125; &#125; for(int i=1; i&lt;=n; ++i) &#123; if(!in[i]) &#123; piv p = dfs(i, ss[i]); if(p.first > ans.first) &#123; ans.first = p.first; ans.second.clear(); ans.second.insert(ans.second.end(), p.second.begin(), p.second.end()); &#125; &#125; &#125; outp(ans.second); printf(\"%d\", ans.first); return 0;&#125;# P1455 搭配购买 套一个并查集。 Code：（2019.12.01） #include &lt;stdio.h>#include &lt;string.h>#include &lt;algorithm>#include &lt;iostream>const int N = 11000; struct node &#123; int c, d;&#125; val[N], tmp[N];int n, m, w, fa[N], list[N], dp[N], t, ans = 0;bool flag[N];int root(int x) &#123; return fa[x] == x ? x : fa[x] = root(fa[x]);&#125;void operator +=(node &amp;A, node B) &#123; A.c += B.c, A.d += B.d;&#125;int main() &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;w); for(int i=1; i&lt;=n; ++i) fa[i] = i; for(int i=1; i&lt;=n; ++i) scanf(\"%d%d\", &amp;val[i].c, &amp;val[i].d); for(int i=1; i&lt;=m; ++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); int u1 = root(u), v1 = root(v); fa[u1] = v1; &#125; for(int i=1; i&lt;=n; ++i) root(i); for(int i=1; i&lt;=n; ++i) tmp[fa[i]] += val[i]; memcpy(list+1, fa+1, n*4); std::sort(list+1, list+n+1); t = std::unique(list+1, list+n+1) - (list+1); for(int i=1; i&lt;=t; ++i) for(int j=w; j>=tmp[list[i]].c; --j) dp[j] = std::max(dp[j], dp[j - tmp[list[i]].c] + tmp[list[i]].d); printf(\"%d\\n\", dp[w]); return 0;&#125;# P1164 小 A 点菜 这怎么会是橙题啊 注意 DP 的初值 dp[0] = 1 ，因为需特别考虑过程中「从 0 开始买菜」的情况。 循环中的 i 表示已经考虑到了前 i 道菜。如果能买的起，就直接把 dp[j-a[i]] 转移过来，否则不变。 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;int dp[11000], n, m, a[110];int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) scanf(\"%d\", &amp;a[i]); dp[0] = 1; for(int i=1; i&lt;=n; ++i) &#123; for(int j=m; j>=a[i]; --j) &#123; dp[j] += dp[j-a[i]]; &#125; &#125; printf(\"%d\\n\", dp[m]); return 0;&#125;# 完全背包 与上面的 01 背包问题差别不大，只是多了一个条件：每个物品可以取无数次。 方法很简单，只要 jjj 从前向后枚举即可。这样做其实是变相利用了它的后效性，使同一个物品可以被多次取到。 # P1616 疯狂的采药 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;int t1, m, dp[int(1e7+10)], t[int(1e4+10)], v[int(1e4+10)];int main() &#123; scanf(\"%d%d\", &amp;t1, &amp;m); for(int i=1; i&lt;=m; ++i) scanf(\"%d%d\", t+i, v+i); for(int i=1; i&lt;=t1; ++i) &#123; dp[i] = dp[i-1]; for(int j=1; j&lt;=m; ++j) if(i-t[j]>=0) dp[i] = max(dp[i], dp[i-t[j]] + v[j]); &#125; printf(\"%d\\n\", dp[t1]); return 0;&#125;# 多重背包 转成 01 背包处理 首先找到最大的 kkk 使得 t=∑i=0k2i(t&lt;ci)t=\\sum_{i=0}^{k}2^i(t &lt; c_i)t=∑i=0k​2i(t&lt;ci​)，也就是找到最大的小于 cic_ici​ 的二的各个次幂和。这样之后，我们就可以通过不重复且有选择地使用 202^020 到 2k2^k2k 来表示出 1 到 t 所有的数。但是剩下的呢？我们将剩下的 ci−tc_i-tci​−t 单独分成一个物品，因为 1 到 t 都可以表示，那么有了这个 ci−tc_i-tci​−t 物品，就可以表示出所有数了。 例如，把 212121 分为 [1,2,4,8,6][1,2,4,8,6][1,2,4,8,6]，这样就可以从中不重复地选择来表示出 1 到 cic_ici​ 的所有数了。 # P1776 宝物筛选 #include &lt;bits/stdc++.h>using namespace std;const int N = 110, M = 44000;int n, W, v[N], w[N], m[N], dp[M];int main() &#123; scanf(\"%d%d\", &amp;n, &amp;W); for(int i=1; i&lt;=n; ++i) scanf(\"%d%d%d\", v+i, w+i, m+i); for(int i=1; i&lt;=n; ++i) &#123; //1, 2, 4, 8, ... 2^k, m_i-2^(k+1)+1 int sum = 0; for(int j=0; sum + (1&lt;&lt;j) &lt;= m[i]; ++j) &#123; sum += (1&lt;&lt;j); for(int l=W; l>=w[i]*(1&lt;&lt;j); --l) dp[l] = max(dp[l], dp[l-w[i]*(1&lt;&lt;j)] + v[i]*(1&lt;&lt;j)); &#125; for(int l=W; l>=w[i]*(m[i] - sum); --l) dp[l] = max(dp[l], dp[l-w[i]*(m[i] - sum)] + v[i]*(m[i] - sum)); &#125; printf(\"%d\\n\", dp[W]); return 0;&#125;# P5020 [NOIP-2018-TG] 货币系统 感觉是道好题，从部分分一步一步优化就可以推出正解的。乍一看可能以为是个数论，其实并不是。 # 80 分做法: 考虑爆搜，枚举现有系统中的每个数能否被其他已选择的数表示出来。这里可以贪心的想，如果一个数能被另外几个数表示，那么删除它一定是更优解。 dfs() 部分可以换成背包，不过复杂度级别是差不多的。 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;algorithm>using namespace std;const int N = 110;bool us[N];int T, n, maxv, t, a[N];bool dfs(int s, int x, int p) &#123; if(x > n or s > a[p]) return false; if(x == p or us[x]) return dfs(s, x+1, p); for(int i=0; i&lt;=maxv/a[x]; ++i) &#123; if(s+a[x]*i == a[p]) return true; bool f = dfs(s+a[x]*i, x+1, p); if(f) return true; &#125; return false;&#125;int main() &#123; scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d\", &amp;n); maxv = 0; for(int i=1; i&lt;=n; ++i) &#123; scanf(\"%d\", a+i); maxv = max(maxv, a[i]); &#125; sort(a+1, a+n+1); t = unique(a+1, a+n+1) - (a+1); int ans = t; memset(us, false, sizeof us); for(int i=1; i&lt;=t; ++i) &#123; if(dfs(0,1,i)) &#123; us[i] = true; --ans; &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;# 满分做法： 其实在 80 分基础上再多想一步就够了：我们不用枚举每个数的表示法来判断可不可以删。直接对所有数 dp，如果一个数能用一种以上的方式表示出来，那么就删掉它。显然删掉这个数是无后效的。 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;algorithm>using namespace std;const int N = 110;bool us[N]; int dp[26000];int T, n, maxv, t, a[N];int main() &#123; scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d\", &amp;n); maxv = 0; for(int i=1; i&lt;=n; ++i) &#123; scanf(\"%d\", a+i); maxv = max(maxv, a[i]); &#125; sort(a+1, a+n+1); t = unique(a+1, a+n+1) - (a+1); int ans = t; memset(dp, 0, sizeof dp); dp[0] = 1; for(int i=1; i&lt;=t; ++i) &#123; for(int j=a[i]; j&lt;=maxv; ++j) &#123; dp[j] += dp[j-a[i]]; &#125; &#125; for(int i=1; i&lt;=t; ++i) &#123; if(dp[a[i]] > 1) --ans; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;# 分组背包 在枚举主件的前提下枚举附件。 # P1064 金明的预算方案 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;vector>using namespace std;const int N = 33000, M = 65;typedef vector&lt;int>::iterator IT;int n, m, p[M], v[M], dp[N];int g[M][2];vector&lt;int> s;int main() &#123; //freopen(\"P1064_5.in\",\"r\",stdin); scanf(\"%d%d\", &amp;n, &amp;m); for(int i=1; i&lt;=m; ++i) &#123; int q; scanf(\"%d%d%d\", &amp;v[i], &amp;p[i], &amp;q); if(q == 0) s.push_back(i); else if(g[q][0]) g[q][1] = i; else g[q][0] = i; &#125; for(IT it = s.begin(); it != s.end(); it++) &#123; int i = *it; int a = g[i][0], b = g[i][1]; for(int j=n; j>=v[i]; --j) &#123; dp[j] = max(dp[j], dp[j-v[i]] + v[i]*p[i]); if(j-v[i]-v[a] >= 0) dp[j] = max(dp[j], dp[j-v[i]-v[a]] + v[i]*p[i] + v[a]*p[a]); if(j-v[i]-v[b] >= 0) dp[j] = max(dp[j], dp[j-v[i]-v[b]] + v[i]*p[i] + v[b]*p[b]); if(j-v[i]-v[a]-v[b] >= 0) dp[j] = max(dp[j], dp[j-v[i]-v[a]-v[b]] + v[i]*p[i] + v[a]*p[a] + v[b]*p[b]); &#125; &#125; printf(\"%d\\n\", dp[n]); return 0;&#125;# 装满背包 一种特殊情况。 背包不一定装满时，dp[j]dp[j]dp[j] 记录的是前 i 件物品放入空间为 j 的背包中的最大价值，要在一开始，让 dp[]dp[]dp[] 中的每个值为 0。 背包装满需要注意： 要把 f[j]f[j]f[j]（表示刚好装满的最大价值）初始化为 f[0] = 0; f[1..n] = -INF; 这样就能使那些能够恰好装满背包的物品的值为正数，而那些不能恰好装满背包的物品的值就为负数，就容易区分了。 dp[n](背包最多承重) == inf 的话，说明装不满；如果装满的话， dp[n] 即为最高价值。","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"},{"name":"动态规划","slug":"algorithm/dp","permalink":"https://snow.js.org/categories/algorithm/dp/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"DFS","slug":"dfs","permalink":"https://snow.js.org/tags/dfs/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://snow.js.org/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"DP","slug":"dp","permalink":"https://snow.js.org/tags/dp/"}]},{"title":"D2T1：贪心、二分、并查集","slug":"D2T1：贪心、二分、并查集","date":"2020-10-16T16:00:00.000Z","updated":"2021-01-19T00:42:42.359Z","comments":true,"path":"noip-d2t1/","link":"","permalink":"https://snow.js.org/noip-d2t1/","excerpt":"","text":"# 常见的贪心技巧 货币使用问题： 尽可能少用，那么我们就先拿面值最大的，依次往下走，最后拿光了即可。 区间调度问题： 工作时间不能重叠，在可选工作中，每次都选取结束时间最早的作为选择，可以使工作量最大。 # 切题小技巧 递归，从后向前 预处理 划分子结构 单调队列、滑动窗口 能剪的枝一定要减！能剪的枝一定要减！能剪的枝一定要减！ 但是剪枝别剪挂了…… # 手动扩栈 编译时指定参数 -Wl,--stack=sizesize 是栈的大小，单位为字节。 # P5686 [CSP-SJX2019] 和积和 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;typedef long long ll;const int N = 500005, P = 1e9+7;int n;ll a[N], b[N], sa[N], sb[N], s[N], ssa[N], ssb[N];int main() &#123; scanf(\"%d\", &amp;n); for(int i=1; i&lt;=n; ++i) scanf(\"%lld\", a+i); for(int i=1; i&lt;=n; ++i) scanf(\"%lld\", b+i); ll ans = 0, s = 0, sa = 0, sb = 0; for(int i=n; i>=1; --i) &#123; sa += a[i]*(n+1-i)%P; sa%=P; sb += b[i]*(n+1-i)%P; sb%=P; ll del = ((a[i]*sb%P + b[i]*sa%P)%P + P - a[i]*b[i]%P*(n-i+1)%P)%P; s += del; s %= P; ans += s; ans %= P; &#125; printf(\"%lld\\n\", ans); return 0;&#125;# U129453 「EZEC-4.5」占座位 题解 #include &lt;bits/stdc++.h>using namespace std;typedef long long ll;map&lt;ll, ll> f;ll n, k;ll dfs(ll n) &#123; if(f[n]) return f[n]; if(n &lt; 2*k+2) return f[n] = 1; return f[n] = dfs(n/2) + dfs(n-n/2);&#125;int main() &#123; scanf(\"%lld%lld\", &amp;n, &amp;k); if(k == 0) printf(\"%lld\\n\", n); else printf(\"%lld\\n\", dfs(n)); return 0;&#125;# P1182 数列分段 Section II #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;typedef long long ll;const int N = 1e5 + 10;int n, m; ll a[N];bool check(ll v) &#123; ll sum = 0, pt = 0; int i=1; while(i&lt;=n) &#123; while(i&lt;=n &amp;&amp; sum + a[i] &lt;= v) &#123; sum += a[i]; ++i; &#125; ++pt; if(pt > m) return false; sum = 0; &#125; return true;&#125;int main() &#123; //freopen(\"p1182_1.in\",\"r\",stdin); scanf(\"%d%d\", &amp;n, &amp;m); ll l=1, r=1e9; for(int i=1; i&lt;=n; ++i) &#123; scanf(\"%lld\", a+i); l = max(l, a[i]); &#125; while(l &lt; r-1) &#123; ll mid = l+(r-l)/2; if(check(mid)) r=mid; else l=mid+1; &#125; if(check(l)) printf(\"%lld\\n\", l); else printf(\"%lld\\n\", r); return 0;&#125;# P2822 组合数问题 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;const int N = 2200, INF = 0x3f3f3f3f;int c[N][N], sum[N][N];int T, k;int main() &#123; scanf(\"%d%d\", &amp;T, &amp;k); c[0][0] = 1; for(int i=1; i&lt;=2000; ++i) &#123; c[i][0] = 1; for(int j=1; j&lt;=i; ++j) &#123; c[i][j] = c[i-1][j-1] + c[i-1][j]; c[i][j] %= k; &#125; &#125; for(int i=0; i&lt;=2000; ++i) &#123; for(int j=0; j&lt;=i; ++j) &#123; sum[i][j] = (c[i][j] == 0); &#125; &#125; for(int i=0; i&lt;=2000; ++i) &#123; for(int j=1; j&lt;=2000; ++j) &#123; sum[i][j] += sum[i][j-1]; &#125; &#125; for(int j=0; j&lt;=2000; ++j) &#123; for(int i=1; i&lt;=2000; ++i) &#123; sum[i][j] += sum[i-1][j]; &#125; &#125; while(T--) &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); printf(\"%d\\n\", sum[n][min(n,m)]); &#125; return 0;&#125;# P1007 独木桥 求最大时间时，把碰面想象成交换身份即可 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;int l, n, p[5005];int main() &#123; scanf(\"%d%d\", &amp;l, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(\"%d\", p+i); int ans1 = 0; for(int i=1; i&lt;=n; ++i) &#123; ans1 = max(ans1, min(p[i], l+1-p[i])); &#125; int ans2 = 0; for(int i=1; i&lt;=n; ++i) &#123; ans2 = max(ans2, max(p[i], l+1-p[i])); &#125; printf(\"%d %d\\n\", ans1, ans2); return 0;&#125;# P3958 奶酪 特点是自底至上找出通路，可以联想至森林合并。 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;algorithm>using namespace std;typedef long long LL;const int N = 1100;struct node &#123; LL x, y, z;&#125; a[N];bool cmp(node a, node b) &#123; return (a.z &lt; b.z);&#125;bool tp[N], bt[N];int fa[N], T, n;LL h, r;int root(int x) &#123; return fa[x]==x?x:root(fa[x]);&#125;bool check(int i, int j) &#123; LL dist = (a[i].x-a[j].x)*(a[i].x-a[j].x) + (a[i].y-a[j].y)*(a[i].y-a[j].y) + (a[i].z-a[j].z)*(a[i].z-a[j].z); return dist &lt;= 4*r*r;&#125;int main() &#123; scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d%lld%lld\", &amp;n, &amp;h, &amp;r); memset(bt, false, sizeof bt); memset(tp, false, sizeof tp); for(int i=1; i&lt;=n; ++i) scanf(\"%lld%lld%lld\", &amp;a[i].x, &amp;a[i].y, &amp;a[i].z); sort(a+1, a+n+1, cmp); for(int i=1; i&lt;=n; ++i) &#123; if(a[i].z - r &lt;= 0) bt[i] = true; if(a[i].z + r >= h) tp[i] = true; &#125; for(int i=1; i&lt;=n; ++i) fa[i] = i; for(int i=1; i&lt;=n; ++i) &#123; for(int j=i+1; j&lt;=n; ++j) &#123; if(check(i, j)) &#123; fa[root(i)] = root(j); &#125; &#125; &#125; bool fla = false; for(int i=1; i&lt;=n; ++i) &#123; if(bt[i] &amp;&amp; tp[root(i)]) &#123; fla = true; break; &#125; &#125; printf(\"%s\", (fla ? \"Yes\\n\" : \"No\\n\")); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"DFS","slug":"dfs","permalink":"https://snow.js.org/tags/dfs/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://snow.js.org/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"}]},{"title":"搜索与状压 DP","slug":"图上动态规划：DAG、树形","date":"2020-10-02T16:00:00.000Z","updated":"2021-01-19T00:42:42.088Z","comments":true,"path":"dp-graph/","link":"","permalink":"https://snow.js.org/dp-graph/","excerpt":"","text":"# DFS 众所周知，搜索和 DP 是不分家的，几乎所有的 DP 都可以转化为搜索。当想不出正解时，DFS 也是骗分的好手段。 主要的搜索手段有： DFS/BFS 爆搜 双向 BFS 启发式搜索（又称 A*） 迭代加深搜索 IDA*（迭代加深 + 启发式） 记忆化搜索 剪枝 重要程度：1,7,6 - 4,3 - 5,2。 下面这几道题都是去年当时不会做的，结果一年过去了，还是不会，呜呜呜 # P3956 棋盘 NOIp 2017 普及 搜索裸题 显然不可以用 vis [] 来判断，因此会搜到重复的状态，考虑记忆化搜索。 网上的题解好像都没有正确性证明，可能觉得太显然了？可我就在这里卡了好久啊 /kk 如果当前格子本来就有颜色，那么魔法一定可用 如果当前格子原本没有颜色，那么只要搜到这个格子，魔法其实只有一种情况就是不可用 而且记搜的时候注意剪枝条件一定要 ** 写到上界！** 比如下面这段代码， f &gt;= mem[x][y] 如果改成 f &gt; mem[x][y] ，100 直接变 70…… #include &lt;bits/stdc++.h>using namespace std;const int N = 110;int m, n, c[N][N], mem[N][N];int d[4][2] = &lt;!--swig￼0-->;int ans = 0x3f3f3f3f;void dfs(int x, int y, int f, int cc) &#123; //f: 代价 //cc != -1 不能用魔法，此处改成的颜色 //cc == -1 可以 if(f >= mem[x][y] || f >= mem[m][m]) return; mem[x][y] = f; if(x == m &amp;&amp; y == m) return; for(int i=0; i&lt;4; ++i) &#123; int xx=x+d[i][0],yy=y+d[i][1]; if(xx&lt;1||xx>m||yy&lt;1||yy>m) continue; if(cc!=-1&amp;&amp;c[xx][yy]==cc||cc==-1&amp;&amp;c[xx][yy]==c[x][y]) &#123; dfs(xx, yy, f, -1); &#125; else if(cc!=-1&amp;&amp;c[xx][yy]!=cc&amp;&amp;c[xx][yy]!=-1||cc==-1&amp;&amp;c[xx][yy]!=c[x][y]&amp;&amp;c[xx][yy]!=-1) &#123; dfs(xx, yy, f+1, -1); &#125; else if(cc==-1&amp;&amp;c[xx][yy]==-1) &#123; dfs(xx, yy, f+2, c[x][y]); &#125; &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;m, &amp;n); memset(c, -1, sizeof c); memset(mem, 0x3f, sizeof mem); for(int i=1; i&lt;=n; ++i) &#123; int x, y, cc; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;cc); c[x][y] = cc; &#125; dfs(1, 1, 0, -1); printf(\"%d\\n\", mem[m][m] == 0x3f3f3f3f ? -1 : mem[m][m]); return 0;&#125;# P3959 宝藏 NOIp 2017 提高 去年做的时候就连 70 分做法都不会。一年过去了，还是不会，呜呜呜 （下面为自己开脱） 这道题的部分分思想其实还挺重要的。 我们知道，一般的 DFS 就是在找出很多单条路径的过程中，获得最优答案。形式也很固定，一般形如： void/int dfs(int u, int sum, int cnt, ...)而这道题不然。 从样例二就可以看出，最终合法方案呈树形，而不是单条路径。一上来可能会想到生成树，但是假掉了。、 反例： 这张图从 1 号点开始的 Prim 便是错的。 如果跑 Prim，从 1 号点开始的话，我们会先访问 2，（此时花费为 1），然后我们会访问 3，此时花费为 3 * 2，然后由于只有 4 号点未访问，这时 3 号的访问顺序为 3，访问 4 号的代价是 3 * 100 = 300，显然这种做法不是最优的，正确的答案应该是 211（从 1 号点开始的最小花费为 211）。 虽然直接跑 Prim 是错的，但是 Prim 的思想仍然重要，这一思想也在最短路等很多算法中有应用：用更新过的点去更新其他点。 我们设计一个不基于点的 dfs 函数，参数只需传递代价，每次迭代，先枚举访问过的点，再枚举一个未访问且未开通路径的点，进行松弛，将代价持续传递下去。计算代价需要记录点的深度，也要通过父节点传递下去。 代码不长，也不难写，说是白给 70 分，其实思路并不好想（虽然比正解 O(n2×3n)O(n^2 \\times 3^n)O(n2×3n) 状压好写多了）。毕竟是紫题嘛，像我这种菜鸡也不打算 AC，能骗多少是多少。 总的来说，这道题的关键还是在于生成树，需要认真看题，熟练运用普及算法（ # Code: #include &lt;cstdio>#include &lt;cstring>const int INF = 0x7f7f7f7f;int min(int a, int b) &#123; return a &lt; b ? a : b; &#125;int map[20][20];int dep[20], best, n, m, num;bool vis[20];void dfs(int x) &#123; if(x >= best) return; // 注意这里的剪枝！ if(num == 0) &#123; best = x; return; &#125; for(int i=1; i&lt;=n; ++i) &#123; if(vis[i]) &#123; for(int j=1; j&lt;=n; ++j) &#123; if(!vis[j] and map[i][j] &lt; INF) &#123; vis[j] = true; --num; dep[j] = dep[i] + 1; dfs(x + map[i][j] * dep[j]); vis[j] = false; ++num; &#125; &#125; &#125; &#125;&#125;int main() &#123; memset(map, 0x7f, sizeof map); scanf(\"%d%d\", &amp;n, &amp;m); for(int i=1; i&lt;=m; ++i) &#123; int x, y, v; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;v); map[x][y] = map[y][x] = min(map[x][y], v); &#125; best = INF; num = n; for(int i=1; i&lt;=n; ++i) &#123; vis[i] = true; --num; dep[i] = 0; dfs(0); vis[i] = false; ++num; &#125; printf(\"%d\\n\", best); return 0;&#125;# 状压 DP # 常用操作 设全集为 xxx for(int y = x; y; y = (y-1) &amp; x) ：枚举 x 的每个子集 x^y ：x 集合中刨去 y x&amp;y == y ：y 是 x 的子集 # P3052 [USACO12MAR]Cows in a Skyscraper G # P3959 宝藏 对就是刚才那道题。 令 fj,i,Sf_{j,i,S}fj,i,S​ 表示从起点到准备向外发边的点 iii 的距离为 jjj，准备要把集合 SSS 中的点挖通 转移时，枚举从节点 iii 打出的边 i-&gt;k，再枚举从 kkk 要打通的子集 S2⊂SS_2\\subset SS2​⊂S，那么 fj,i,S=min⁡k∈S2⊂S(d[i][k]∗(j+1)+fj+1,k,S2−{k}+fj,i,S−S2)f_{j, i, S} = \\min_{k \\in S_2 \\subset S} (d[i][k] * (j + 1) + f_{j + 1, k, S_2 - \\{k\\}} + f_{j, i, S - S_2}) fj,i,S​=k∈S2​⊂Smin​(d[i][k]∗(j+1)+fj+1,k,S2​−{k}​+fj,i,S−S2​​) 转移顺序一定要想好。 最后取所有 f0,i,U−if_{0,i,U-{i}}f0,i,U−i​ 的最小值即可，其中 UUU 是全集。 核心代码 // 预处理集合中 1 的个数 for (int i = 1; i &lt; mx; ++i) sz[i] = sz[i &amp; (i - 1)] + 1; // 预处理 lowbit for (int i = 0; i &lt; n; ++i) mn[1 &lt;&lt; i] = i; for (int i = 1; i &lt; mx; ++i) mn[i] = mn[i &amp; -i]; for (int i = 0; i &lt; n; ++i) f[n - 1][i][0] = 0; // 初值 for (int j = n - 2; j >= 0; --j) &#123; // 距离 for (int i = 0; i &lt; n; ++i) &#123; // 发边点 f[j][i][0] = 0; // 初值 for (int S = 1; S &lt; (1 &lt;&lt; n); ++S) &#123; if (((~S >> i) &amp; 1) //i 不在集合 S 里 &amp;&amp; sz[S] &lt;= n - j - 1) // 不会多挖 for (int S2 = S; S2; S2 = (S2 - 1) &amp; S) &#123; //S 的每个子集 int tmp = S2; for (int k = mn[tmp]; tmp; k = mn[tmp &amp;= ~(1 &lt;&lt; k)]) //S2 里的每个点 if (mp[i][k] ^ INF) // 存在待挖的边 f[j][i][S] = min(f[j][i][S], f[j + 1][k][S2 &amp; ~(1 &lt;&lt; k)] + f[j][i][S &amp; ~S2] + mp[i][k] * (j + 1)); &#125; &#125; &#125; &#125; int ans = INF; for (int i = 0; i &lt; n; ++i) ans = std::min(ans, f[0][i][(mx - 1) &amp; ~(1 &lt;&lt; i)]);","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"},{"name":"动态规划","slug":"algorithm/dp","permalink":"https://snow.js.org/categories/algorithm/dp/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"DFS","slug":"dfs","permalink":"https://snow.js.org/tags/dfs/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://snow.js.org/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"DP","slug":"dp","permalink":"https://snow.js.org/tags/dp/"},{"name":"图论","slug":"图论","permalink":"https://snow.js.org/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"树","slug":"树","permalink":"https://snow.js.org/tags/%E6%A0%91/"}]},{"title":"高级动态规划：区间、树形","slug":"高级动态规划：区间、状压","date":"2020-10-01T16:00:00.000Z","updated":"2021-01-19T00:42:42.360Z","comments":true,"path":"dp-series/","link":"","permalink":"https://snow.js.org/dp-series/","excerpt":"","text":"# 区间 DP # P1880 [NOI1995] 石子合并 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;const int N = 220;int ans, dp[N][N], n, a[N], s[N];int main() &#123; scanf(\"%d\", &amp;n); for(int i=1; i&lt;=n; ++i) &#123; scanf(\"%d\", a+i); s[i] = s[i-1] + a[i]; &#125; for(int i=1; i&lt;=n; ++i) &#123; s[i+n] = s[i+n-1] + a[i]; &#125; memset(dp, 0x3f, sizeof dp); for(int i=1; i&lt;=2*n; ++i) dp[i][i] = 0; for(int l=2; l&lt;=n; ++l) &#123; for(int i=1, j=l; j&lt;=2*n; ++i, ++j) &#123; for(int k=i; k&lt;j; ++k) &#123; dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + s[j] - s[i-1]); &#125; &#125; &#125; ans = 0x3f3f3f3f; for(int i=1; i&lt;=n; ++i) &#123; //printf(\"%d \", dp[i][i+n-1]); ans = min(ans, dp[i][i+n-1]); &#125; printf(\"%d\\n\", ans); memset(dp, 0, sizeof dp); for(int i=1; i&lt;=2*n; ++i) dp[i][i] = 0; for(int l=2; l&lt;=n; ++l) &#123; for(int i=1, j=l; j&lt;=2*n; ++i, ++j) &#123; for(int k=i; k&lt;j; ++k) &#123; dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + s[j] - s[i-1]); &#125; &#125; &#125; ans = 0; for(int i=1; i&lt;=n; ++i) &#123; ans = max(ans, dp[i][i+n-1]); &#125; printf(\"%d\\n\", ans); return 0;&#125;# P1063 能量项链 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;const int N = 220;int n, h[N], t[N], dp[N][N];int main() &#123; scanf(\"%d\", &amp;n); for(int i=1; i&lt;=n; ++i) &#123; scanf(\"%d\", &amp;h[i]); h[i+n] = h[i]; &#125; for(int i=1; i&lt;2*n; ++i) t[i] = h[i+1]; for(int l=2; l&lt;=n; ++l) &#123; for(int i=1, j=l; j&lt;=2*n; ++i, ++j) &#123; for(int k=i; k&lt;j; ++k) &#123; dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + h[i] * t[k] * t[j]); &#125; &#125; &#125; int ans = 0; for(int i=1; i&lt;=n; ++i) &#123; ans = max(ans, dp[i][i+n-1]); &#125; printf(\"%d\\n\", ans); return 0;&#125;# P3146 [USACO16OPEN]248 G #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;int n, dp[300][300], ans = 0;int main() &#123; scanf(\"%d\", &amp;n); for(int i=1; i&lt;=n; ++i) &#123; scanf(\"%d\", &amp;dp[i][i]); &#125; for(int l=2; l&lt;=n; ++l) &#123; for(int i=1, j=l; j&lt;=n; ++i, ++j)&#123; for(int k=i; k&lt;j; ++k) &#123; if(dp[i][k] == dp[k+1][j]) dp[i][j] = max(dp[i][j], dp[i][k]+1); &#125; ans = max(ans, dp[i][j]); &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125;# 树形 DP 树形 DP 三大问题：树的最大独立集 树的重心 树的最长路径 # P1352 没有上司的舞会 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;vector>using namespace std;typedef vector&lt;int>::iterator IT;const int N = 6e3 + 10;int fa[N]; vector&lt;int> g[N];int n, r[N];inline int fin() &#123; for(int i=1; i&lt;=n; ++i) if(!fa[i]) return i;&#125;int f[N][2];// 0/1void dfs(int u) &#123; f[u][0] = 0; f[u][1] = r[u]; for(IT it = g[u].begin(); it != g[u].end(); ++it) &#123; dfs(*it); f[u][0] += max(f[*it][0], f[*it][1]); f[u][1] += f[*it][0]; &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for(int i=1; i&lt;=n; ++i) scanf(\"%d\", r+i); for(int i=1; i&lt;n; ++i) &#123; int l, k; scanf(\"%d%d\", &amp;l, &amp;k); fa[l] = k; g[k].push_back(l); &#125; int rt = fin(); dfs(rt); printf(\"%d\", max(f[rt][0], f[rt][1])); return 0;&#125;# P2014 [CTSC1997] 选课 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;vector>using namespace std;const int N = 330;vector&lt;int> g[N];int n, m; int dp[N][N];void dfs(int u) &#123; for(vector&lt;int>::iterator it = g[u].begin(); it != g[u].end(); it++) &#123; dfs(*it); for(int j=m+1; j>1; --j) &#123; for(int k=0; k&lt;j; ++k) dp[u][j] = max(dp[u][j], dp[*it][k] + dp[u][j-k]); &#125; &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) &#123; int k; scanf(\"%d%d\", &amp;k, &amp;dp[i][1]); g[k].push_back(i); &#125; dfs(0); printf(\"%d\\n\", dp[0][m+1]); return 0;&#125;","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"},{"name":"动态规划","slug":"algorithm/dp","permalink":"https://snow.js.org/categories/algorithm/dp/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"DFS","slug":"dfs","permalink":"https://snow.js.org/tags/dfs/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://snow.js.org/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"DP","slug":"dp","permalink":"https://snow.js.org/tags/dp/"},{"name":"树","slug":"树","permalink":"https://snow.js.org/tags/%E6%A0%91/"}]},{"title":"Butterfly：添加全局吸底 Aplayer 播放器","slug":"Butterfly：添加全局吸底 Aplayer 播放器","date":"2020-08-21T16:00:00.000Z","updated":"2021-01-19T00:42:42.360Z","comments":true,"path":"butterfly-aplayer/","link":"","permalink":"https://snow.js.org/butterfly-aplayer/","excerpt":"","text":"# Butterfly：添加全局吸底 Aplayer 播放器 以下步骤在 Butterfly 主题上可以正常生效。如果你使用的是其他主题，可以根据情况自行适配。 # 配置播放器 # 解决与 hexo-tag-aplayer 的兼容问题 如果你没有安装过 hexo-tag-aplayer 插件，请直接跳过该步骤。 如果你安装过 hexo-tag-aplayer ，请在 Hexo 的配置文件中修改以下设置： aplayer: meting: true asset_inject: false# 开启主题的 aplayerInject 选项 在主题配置文件中，enable 和 per_page 均设为 true： # Inject the css and script (aplayer/meting)aplayerInject: enable: true per_page: true# 插入 Aplayer 代码 插入到主题配置文件的 inject.bottom 。 示例代码： inject: ... bottom: - &lt;div class=\"aplayer no-destroy\" data-id=\"000PeZCQ1i4XVs\" data-server=\"tencent\" data-type=\"artist\" data-fixed=\"true\" data-mini=\"true\" data-listFolded=\"false\" data-order=\"random\" data-preload=\"none\" data-autoplay=\"true\" muted>&lt;/div>参数解释： option default description data-id require song id / playlist id / album id / search keyword data-server require music platform: netease, tencent, kugou, xiami, baidu data-type require song, playlist, album, search, artist data-autoplay false audio autoplay data-theme #2980b9 main color data-loop all player loop play, values: ‘all’, ‘one’, ‘none’ data-order list player play order, values: ‘list’, ‘random’ data-preload auto values: ‘none’, ‘metadata’, ‘auto’ data-volume 0.7 default volume, notice that player will remember user setting, default volume will not work after user set volume themselves data-mutex true prevent to play multiple player at the same time, pause other players when this player start play data-lrctype 0 歌词来源方式，一般不更改 data-listfolded false indicate whether list(指播放列表，不是播放器) should folded at first data-listmaxheight 340px list max height data-storagename metingjs localStorage key that store player setting 注意： data-id 、 data-server 和 data-type 必须配置 data-fixed 和 data-mini 参数不要更改 运行 Hexo 就可以看到网页左下角出现了 Aplayer。 如果你想切换页面时音乐不中断，请把主题配置文件的 pjax 设为 true 。 # UI 调整 # 调整右下角回到顶部等按钮 按照上面的步骤设置完成后，浏览器左下角会出现 Aplayer。在手机端浏览博客时，如果展开播放器，会将右下角按钮遮住。 在 Butterfly 配置文件中，调整 rightside-bottom 选项： # the position of bottom right button; default unit: px (右下角按鈕距離底部的距離，默認單位為 px)rightside-bottom: 80px# 调整 TOC 目录按钮 打开文章页面时，你会发现打开 Toc 目录的按钮被遮挡了。我们需要修改 CSS 来改变按钮的位置。 请在主题配置文件中，将这段代码添加到 inject 去： inject: head: - '&lt;style type=\"text/css\">#toggle-sidebar &#123;bottom: 80px&#125;&lt;/style>'# 调整 Aplayer 收回方式 如果你觉得 Aplayer 占地太大，影响正常阅读，可以设置 Aplayer 收回时将音乐 Cover 也隐藏掉，只留下右侧的箭头栏。 请在主题配置文件中，将这段代码添加到 inject 去： inject: head: - '&lt;style type=\"text/css\">.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body&#123;left:-66px!important&#125;.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover&#123;left:0!important&#125;&lt;/style>'# 调整 APlayer 歌词显示 Aplayer 的歌词默认在底部正中显示，也会遮挡一些内容。当然我们可以通过调整相应内容高度的方式来解决，但是如果可以设置歌词默认不显示，效果可能会更好。 解决方案：修改 Butterfly 配置文件中的 CDN.meting_js 配置，将 CDN 链接替换即可。 CDN: ... # aplayer aplayer_css: https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css aplayer_js: https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js- meting_js: https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js+ meting_js: https://cdn.jsdelivr.net/gh/SerokSSR/cdn/meting.min.js","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://snow.js.org/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://snow.js.org/tags/hexo/"},{"name":"Butterfly","slug":"butterfly","permalink":"https://snow.js.org/tags/butterfly/"},{"name":"Aplayer","slug":"aplayer","permalink":"https://snow.js.org/tags/aplayer/"},{"name":"博客","slug":"博客","permalink":"https://snow.js.org/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"C++ STL：SET & MULTISET","slug":"C++ STL：SET & MULTISET","date":"2020-08-11T16:00:00.000Z","updated":"2021-01-19T00:42:42.360Z","comments":true,"path":"stl-set/","link":"","permalink":"https://snow.js.org/stl-set/","excerpt":"","text":"# C++ STL：SET &amp; MULTISET # 定义 方式 效果 set &lt;数据类型名&gt; 集合名; 先定义一个容器，容器内无任何元素 set &lt;数据类型名&gt; 集合名(另一个集合名); 定义一个集合并用另一个集合初始化（只能是数据类型相同的集合，不能是数组） set &lt;数据类型名&gt; 集合名(另一个集合名.begin(), 另一个集合名.end()); 定义一个集合并用另一个集合初始化（只能是数据类型相同的集合，不能是数组） set &lt;数据类型名&gt; 集合名[集合数量]; 定义集合数组 set &lt;Elem&gt; 产生一个 set，以 (operator &lt;) 为排序准则 set &lt;Elem, cmp&gt; 产生一个 set，以 cmp 为排序准则 # 操作 # 非变动性操作 操作 效果 c.size() 返回当前的元素数量 c.empty () 判断 set 是否为空，等同于 c.size () == 0，效率更高 c.max_size() 返回能容纳的元素最大数量 c1 == c2 判断 c1 是否等于 c2 # 查找 set 和 multiset 都是平衡树，O(log⁡n)O(\\log n)O(logn) 级别查找。 操作 效果 count(elem) 返回元素值为 elem 的个数 find(elem) 返回元素值为 elem 的第一个元素，如果没有返回 end () lower_bound(elem) 返回元素值为 elem 的第一个可安插位置，也就是元素值 &gt;= elem 的第一个元素位置 upper_bound(elem) 返回元素值为 elem 的最后一个可安插位置，也就是元素值 &gt; elem 的第一个元素位置 equal_range(elem) 返回 elem 可安插的第一个位置和最后一个位置，也就是元素值 == elem 的区间 # 赋值与迭代 sets 和 multisets 的迭代器是双向迭代器，对迭代器操作而言，所有的元素都被视为常数，可以确保你不会人为改变元素值，从而打乱既定顺序，所以无法调用变动性算法，如 remove() 。 操作 效果 c1 = c2 将 c2 的元素全部给 c1 c1.swap(c2) 将 c1 和 c2 的元素互换 swap(c1, c2) 同上，全局函数 c.begin() 略 c.end() 略 c.rbegin() 略 c.rend() 略 # 安插和删除元素 必须保证参数有效，迭代器必须指向有效位置，序列起点不能位于终点之后，不能从空容器删除元素。 操作 返回值 效果 c.insert(elem) pair &lt;iterator, bool&gt; 插入一个 elem 副本 c.insert(pos, elem) iterator 安插一个 elem 元素副本，返回元素的迭代器。pos 为搜索起点，提升插入速度。 c.insert(beg,end) void 将区间 [beg,end) 所有的元素安插到 c。 c.erase(elem) 无符号整数 删除与 elem 相等的所有元素，返回被移除的元素个数。 c.erase(pos) void 移除迭代器 pos 所指位置元素。 c.erase(beg,end) void 移除区间 [beg,end) 所有元素，返回 void 。 c.clear() void 移除所有元素，将容器清空 # set 与 multiset 的异同 set::insert(key) 的返回值是一个 pair&lt;iterator, bool&gt; ，其中 pair 中的 bool 成员表明了 key 被插入之前，set 中是否已存在相同的 key。如果 set 中已经存在相同 key 的元素，那么插入操作是会失败的，新的元素不会被插进去。而 multiset::insert(key) 的返回值只是一个 iterator，插入操作总是会成功的。 multiset::count(key) 的返回值可能大于 1。 multiset::size() 的返回值是 multiset 中元素的个数，而不是值的个数。比如，{1, 1, 2} 的 size 是 3，而不是 2。 multiset::erase(key) 会将对应的 key 全部删掉，所以对 {1, 1, 2} 调用 erase(1) 之后，它就变成了 {2}。 只要 key 存在于集合中， set::equal_range(key) 的返回值 pair&lt;iterator1, iterator2&gt; 总是会有 ++iterator1 == iterator2 。但是对 multiset 来说就不一定了。","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://snow.js.org/tags/%E6%8E%92%E5%BA%8F/"},{"name":"STL","slug":"stl","permalink":"https://snow.js.org/tags/stl/"}]},{"title":"Hexo：将你的博客部署到 Vercel","slug":"Hexo：将你的博客部署到 Vercel","date":"2020-08-08T16:00:00.000Z","updated":"2021-01-19T00:42:42.359Z","comments":true,"path":"hexo-vercel/","link":"","permalink":"https://snow.js.org/hexo-vercel/","excerpt":"","text":"# Hexo：将你的博客部署到 Vercel # 写在前面 近些日子，静态网站的热度又渐渐高了起来。相比于动态网站，静态网站具有轻量、无需服务器、利于 SEO、速度快等特点，非常适合个人博客。再加上 Hexo、Hugo 等静态博客渲染框架的日渐成熟，已能与 Wordpress、Typecho 等老牌动态博客框架分庭抗礼。 与此同时，很多静态托管网站也应运而生。各种托管网站看似鱼龙混杂，其实由于各种原因，在国内能用的也就那么几家；如果你像我一样，没有服务器、没有备案，还想白嫖（穷），那么仅有的选择就更少了。综合各种因素，目前最适合托管静态博客的服务有： # GitHub Pages 微软旗下，闻名遐迩的全球第一大开源仓库网站。服务器设在荷兰、美国等地，近期由于一些原因，部分地区部分运营商的用户遭到 DNS 污染，无法正常访问。 # Gitee Pages OSCHINA 旗下，服务器在上海腾讯云，速度较快，较稳定，提供 xxx.gitee.io 域名，不支持免费自定义域名。 # Coding Pages ---2020.11.3 更新：Coding 取消了原先的免费托管服务。新版需要配合腾讯云食用，基本上没啥意义了。--- 腾讯旗下，服务器在香港 / 新加坡腾讯云，速度尚可，但稳定性差。部分地区速度极慢，一些地区的 CMCC 宽带甚至不能访问。支持免费自定义域名。 # Vercel 原名 Zeit，服务器在美国，在港台有 CDN 节点。速度略慢于 Coding，但大部分地区均可正常访问，不过晚上速度会慢一些。提供自定义 xxx.now.sh 和 xxx.vercel.app 域名，且支持免费绑定个人域名。 大部分网站采用的一般都是 GitHub + Coding 双部署的形式。这种方法比较麻烦，需要 DNSPod 解析，因此需要实名认证，而且还真未必快到那里去。 Colsrch 大佬出过一篇三部署教程，使用了 Coding（联通线路），Vercel（默认线路），Cloudflare 回源 GitHub Page（移动线路），速度略有提升，但是门槛较高，对小白并不友好。而且近期 Coding 似乎越来越不稳定了，所以也不太推荐此方法。 下面是晚上六点左右，Vercel 与 Gitee 的速度对比。和 99 块钱相比，慢点就慢点吧（ 还是由于某种原因，市面上的 Vercel 部署教程并不多。而且由于 Vercel 里的一些操作还是挺不常规的，所以就写了这么一篇文章，说一下将网站部署在 Vercel 的详细过程。 # 导入 GitHub 仓库 Vercel 是一个静态网页部署网站，并不托管代码。因此，我们通过 GitHub 来托管 hexo deploy 生成的网页文件，并设置自动导入。当你的源代码仓库有变动后，Vercel 会第一时间检测到并重新部署网站，部署完成后会通过邮件提醒。 在开始之前，请准备一个 GitHub 账号（注意不能是绑有 QQ 邮箱的）、一个 Git 仓库（存储 Hexo 生成的页面）。 进入 Vercel 官网，点击 Continue with GitHub 注意：如果出现下图所示的情况，请确认你的 GitHub 账号上没有绑 QQ 邮箱（即便它不是主邮箱）。如果仍然报错，请换用国外邮箱。 授权完成后，选择 Import Git Repository ，点击 Continue，进入如下界面。输入你的仓库 url（https）。 如果你配置过 GitHub Pages，那么这个地方直接填入你的 GitHub Pages 仓库就可以了。 注意：你生成的页面应推送至 master 分支，而不是 gh-pages 分支。如果你之前设置了多部署，比如： deploy: type: git repo: github: xxx coding: xxx branch: master请务必将 GitHub 拆出来单独写，就像这样： deploy:- type: git repo: coding: xxx- type: git repo: git@github.com:xxx/xxx.git branch: master因为如果按照第一种方式，你的生成页面有一定概率会被推送至 gh-pages 分支（由于 Hexo 的默认设置），导致 Vercel 无法拉取。 导入项目中会弹出一些自定义选项，不知道会出什么锅的话就不要改，顺着右下角的蓝色键一直点，遵照默认选项就可以了。 这里建议选择 All repo ，方便后续部署。 部署完成后，Vercel 会提供几个默认域名，可以通过 [项目名].[用户名].vercel.app 访问。 # 自定义域名 进入 dashboard，点击 [项目卡片] -&gt; View Domains 如果你想使用 Vercel 提供的二级域名，直接添加 xxx.now.sh （或 xxx.vercel.app ，看你想要哪个），如果无人占用，会自动验证成功。 如果你想绑定自己的域名，也是在输入框中输入你想要绑定的网址，点击右侧 Add 即可。下方会提示 Invalid Config，并给出两种绑定方式（A/CNAME + NS），但是不要听他的，而是请按照下面的方式： # 验证方式 如果是根域名，请在你的 DNS 解析处添加 A 记录，指向 76.76.21.21 如果是子域名，请在你的 DNS 解析处添加 CNAME 记录，指向 cname.vercel-dns.com 添加记录后等待片刻再刷新，下面显示两个对号即表明验证成功。 # 重定向 如果你绑定了多个域名，可以点击域名卡片右上角的 Edit，将某个域名重定向至你的其他域名。 # 后话 至此 Vercel 的部署过程就结束了。 初次部署后再进入 dashboard，可能会偶尔出现配置好的域名显示 invalid config 的现象，尽管 DNS 解析是正常的。经博主测试，此状态下网页仍能正常访问（已排除 DNS 缓存的问题），可能是 Vercel 面板的 bug 吧。 如果你在部署过程中有什么问题，可以可以在下方留言，或者直接向 support@vercel.com 发邮件，能不能用中文我没试过。免费用户一般回复时间不早于 48h ，不晚于 96h。","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://snow.js.org/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://snow.js.org/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://snow.js.org/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"部署","slug":"部署","permalink":"https://snow.js.org/tags/%E9%83%A8%E7%BD%B2/"},{"name":"Vercel","slug":"vercel","permalink":"https://snow.js.org/tags/vercel/"}]},{"title":"Hexo：为你的博客配置 PWA","slug":"Hexo：为你的博客配置 PWA","date":"2020-08-03T16:00:00.000Z","updated":"2021-01-19T00:42:42.358Z","comments":true,"path":"hexo-gulp-pwa/","link":"","permalink":"https://snow.js.org/hexo-gulp-pwa/","excerpt":"","text":"# Hexo：使用 Gulp 为你的博客配置 PWA 使用这个方法之前，请先卸载掉其它的 PWA 插件，并安装 Gulp 和 WorkBox。 npm install gulp-cli -gnpm install workbox-build gulp --save-dev本文参考利用 Workbox 实现博客的 PWA 和 Butterfly 进阶教程。 # 写在前面 渐进式网络应用程式（英语：Progressive Web Apps，简称：PWA）是一种普通网页或网站架构起来的网络应用程式，但它可以以传统应用程式或原生移动应用程式形式展示给用户。这种应用程式形态视图将目前最为现代化的浏览器提供的功能与行动装置的体验优势相结合。 当你的网站实现了 PWA，那就代表了 用户可以添加你的博客到电脑 / 手机的桌面，以原生应用般的方式浏览你的博客 用户本地可以自动生成缓存，二次访问速度大大加快 用户可以离线浏览你的博客 下面的 PWA 实现方法借助了 Gulp 插件，在站点有内容更新时，可以弹窗提醒用户刷新页面。 # 开启主题相关设置 以 Butterfly 主题为例，在 butterfly.yml 中开启 PWA 选项 实例： pwa: enable: true manifest: /manifest.json # 清单文件，下文将介绍如何生成 theme_color: \"#fff\" # 应用程序顶栏的背景色 apple_touch_icon: /img/pwa/apple-touch-icon.png # 添加至苹果移动设备的主屏幕后显示的图标，尽量使用 png 格式 favicon_32_32: /img/pwa/32.png # 32 * 32 像素，网页图标 favicon_16_16: /img/pwa/16.png # 16 * 16 像素，网页图标 mask_icon: /img/pwa/safari-pinned-tab.svg # 苹果电脑 Touch Bar 区域显示的收藏栏封面图，须使用 svg 格式图片尺寸要求： apple_touch_icon：192 * 192 像素 mask_icon：viewBox 的值必须是 0 0 16 16 如果你的主题没有内置 PWA，下面附有 Butterfly 主题的 PWA 部分，可以根据你所用的主题调整下面的 Pug 模板，编译后插入到 html 生成模板的 head 处。 link(rel=\"manifest\" href=url_for(theme.pwa.manifest))if(theme.pwa.theme_color) meta(name=\"theme-color\" content=theme.pwa.theme_color)if(theme.pwa.theme_color) meta(name=\"msapplication-TileColor\" content=theme.pwa.theme_color)if(theme.pwa.apple_touch_icon) link(rel=\"apple-touch-icon\" sizes=\"180x180\" href=url_for(theme.pwa.apple_touch_icon))if(theme.pwa.favicon_32_32) link(rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=url_for(theme.pwa.favicon_32_32))if(theme.pwa.favicon_16_16) link(rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=url_for(theme.pwa.favicon_16_16))if(theme.pwa.mask_icon) link(rel=\"mask-icon\" href=url_for(theme.pwa.mask_icon) color=\"#5bbad5\")# 配置 manifest.json 创建 manifest.json ，路径应与配置文件中所填路径相同。 实例及配置说明： &#123; \"name\": \"Serok's Blog\", // 应用全称 \"short_name\": \"Seeker\", // 应用简称 \"theme_color\": \"#49b1f5\", // 应用主题色 \"background_color\": \"#49b1f5\", // 加载应用时的背景色 \"display\": \"minimal-ui\", // 首選顯示模式 // 更多顯示模式：\"fullscreen\", \"standalone\", \"browser\" \"scope\": \"/\", \"start_url\": \"/\", \"icons\": [ // 指定 icons 參數，用來適配不同設備 // 需為 png 格式，至少包含一个 192 * 192 像素的圖標 &#123; \"src\": \"https://snow.js.org/image/pwaicons/192.png\", // 建议采用绝对路径 \"sizes\": \"192x192\", \"type\": \"image/png\" &#125; ], \"splash_pages\": null // 自定義启动动画&#125;default Hexo 采用的是严格 Json 规范，因此 manifest.json 文件配置好后，需删除文件中的所有注释。 # 安装插件 在命令行中输入 npm install workbox-build gulp --save-dev# 创建 gulpfile.js 文件 在博客的根目录下，创建一个 gulpfile.js 文件 const gulp = require(\"gulp\");const workbox = require(\"workbox-build\");gulp.task('generate-service-worker', () => &#123; return workbox.injectManifest(&#123; swSrc: './sw-template.js', swDest: './public/sw.js', globDirectory: './public', globPatterns: [ \"**/*.&#123;html,css,js,json,woff2&#125;\" ], modifyURLPrefix: &#123; \"\": \"./\" &#125; &#125;);&#125;);gulp.task(\"build\", gulp.series(\"generate-service-worker\"));# 创建 sw-template.js 文件 在博客的根目录下，创建一个 sw-template.js 文件 const workboxVersion = '5.1.3';importScripts(`https://storage.googleapis.com/workbox-cdn/releases/$&#123;workboxVersion&#125;/workbox-sw.js`);workbox.core.setCacheNameDetails(&#123; prefix: \"Serok's Blog\"&#125;);workbox.core.skipWaiting();workbox.core.clientsClaim();workbox.precaching.precacheAndRoute(self.__WB_MANIFEST,&#123; directoryIndex: null&#125;);workbox.precaching.cleanupOutdatedCaches();// Imagesworkbox.routing.registerRoute( /\\.(?:png|jpg|jpeg|gif|bmp|webp|svg|ico)$/, new workbox.strategies.CacheFirst(&#123; cacheName: \"images\", plugins: [ new workbox.expiration.ExpirationPlugin(&#123; maxEntries: 1000, maxAgeSeconds: 60 * 60 * 24 * 30 &#125;), new workbox.cacheableResponse.CacheableResponsePlugin(&#123; statuses: [0, 200] &#125;) ] &#125;));// Fontsworkbox.routing.registerRoute( /\\.(?:eot|ttf|woff|woff2)$/, new workbox.strategies.CacheFirst(&#123; cacheName: \"fonts\", plugins: [ new workbox.expiration.ExpirationPlugin(&#123; maxEntries: 1000, maxAgeSeconds: 60 * 60 * 24 * 30 &#125;), new workbox.cacheableResponse.CacheableResponsePlugin(&#123; statuses: [0, 200] &#125;) ] &#125;));// Google Fontsworkbox.routing.registerRoute( /^https:\\/\\/fonts\\.googleapis\\.com/, new workbox.strategies.StaleWhileRevalidate(&#123; cacheName: \"google-fonts-stylesheets\" &#125;));workbox.routing.registerRoute( /^https:\\/\\/fonts\\.gstatic\\.com/, new workbox.strategies.CacheFirst(&#123; cacheName: 'google-fonts-webfonts', plugins: [ new workbox.expiration.ExpirationPlugin(&#123; maxEntries: 1000, maxAgeSeconds: 60 * 60 * 24 * 30 &#125;), new workbox.cacheableResponse.CacheableResponsePlugin(&#123; statuses: [0, 200] &#125;) ] &#125;));// Static Librariesworkbox.routing.registerRoute( /^https:\\/\\/cdn\\.jsdelivr\\.net/, new workbox.strategies.CacheFirst(&#123; cacheName: \"static-libs\", plugins: [ new workbox.expiration.ExpirationPlugin(&#123; maxEntries: 1000, maxAgeSeconds: 60 * 60 * 24 * 30 &#125;), new workbox.cacheableResponse.CacheableResponsePlugin(&#123; statuses: [0, 200] &#125;) ] &#125;));workbox.googleAnalytics.initialize();注意：把 prefix 修改为你博客的名字（最好用英文）。 上面的文件涵盖了大多数资源的缓存策略。如果你想缓存其他类型的资源（例如一些国内的镜像 CDN 库），或者想使用其他的缓存方式，请自行查看相关文档并添加。 # 添加 js 进主题 配置 butterfly.yml , 添加需要的 css 和 js inject: head: - '&lt;style type=\"text/css\">.app-refresh&#123;position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease&#125;.app-refresh-wrap&#123;display:flex;color:#fff;height:100%;align-items:center;justify-content:center&#125;.app-refresh-wrap a&#123;color:#fff;text-decoration:underline;cursor:pointer&#125;&lt;/style>' bottom: - '&lt;div class=\"app-refresh\" id=\"app-refresh\"> &lt;div class=\"app-refresh-wrap\"> &lt;label>✨ 网站已更新最新版本 👉&lt;/label> &lt;a href=\"javascript:void(0)\" onclick=\"location.reload()\">点击刷新&lt;/a> &lt;/div>&lt;/div>&lt;script>function showNotification()&#123;if(GLOBAL_CONFIG.Snackbar)&#123;var t=\"light\"===document.documentElement.getAttribute(\"data-theme\")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show(&#123;text:\"已更新最新版本\",backgroundColor:t,duration:5e5,pos:e,actionText:\"点击刷新\",actionTextColor:\"#fff\",onActionClick:function(t)&#123;location.reload()&#125;&#125;)&#125;else&#123;var o=`top: 0; background: $&#123;\"light\"===document.documentElement.getAttribute(\"data-theme\")?\"#49b1f5\":\"#1f1f1f\"&#125;;`;document.getElementById(\"app-refresh\").style.cssText=o&#125;&#125;\"serviceWorker\"in navigator&amp;&amp;(navigator.serviceWorker.controller&amp;&amp;navigator.serviceWorker.addEventListener(\"controllerchange\",function()&#123;showNotification()&#125;),window.addEventListener(\"load\",function()&#123;navigator.serviceWorker.register(\"/sw.js\")&#125;));&lt;/script>'同样，如果你使用的不是 Butterfly 主题，可以在所示代码的基础上修改以适配你的主题。以下是展开后的代码，便于修改调试。 # 以下代码请插入到头部 &lt;/head&gt; 之前： &lt;style type=\"text/css\"> .app-refresh &#123; position: fixed; top: -2.2rem; left: 0; right: 0; z-index: 99999; padding: 0 1rem; font-size: 15px; height: 2.2rem; transition: all 0.3s ease; &#125; .app-refresh-wrap &#123; display: flex; color: #fff; height: 100%; align-items: center; justify-content: center; &#125; .app-refresh-wrap span &#123; color: #fff; text-decoration: underline; cursor: pointer; &#125;&lt;/style># 以下代码请插入到底部 &lt;/body&gt; 之前： &lt;div class=\"app-refresh\" id=\"app-refresh\"> &lt;div class=\"app-refresh-wrap\"> &lt;label>✨ 网站已更新最新版本 👉&lt;/label> &lt;a href=\"javascript:void(0)\" onclick=\"location.reload()\">点击刷新&lt;/a> &lt;/div>&lt;/div>&lt;script> if ('serviceWorker' in navigator) &#123; if (navigator.serviceWorker.controller) &#123; navigator.serviceWorker.addEventListener('controllerchange', function () &#123; showNotification() &#125;) &#125; window.addEventListener('load', function () &#123; navigator.serviceWorker.register('/sw.js') &#125;) &#125; function showNotification() &#123; if (GLOBAL_CONFIG.Snackbar) &#123; var snackbarBg = document.documentElement.getAttribute('data-theme') === 'light' ? GLOBAL_CONFIG.Snackbar.bgLight : GLOBAL_CONFIG.Snackbar.bgDark var snackbarPos = GLOBAL_CONFIG.Snackbar.position Snackbar.show(&#123; text: '已更新最新版本', backgroundColor: snackbarBg, duration: 500000, pos: snackbarPos, actionText: '点击刷新', actionTextColor: '#fff', onActionClick: function (e) &#123; location.reload() &#125;, &#125;) &#125; else &#123; var showBg = document.documentElement.getAttribute('data-theme') === 'light' ? '#49b1f5' : '#1f1f1f' var cssText = `top: 0; background: $&#123;showBg&#125;;` document.getElementById('app-refresh').style.cssText = cssText &#125; &#125;&lt;/script># 运行 为了方便每次部署，可以在你的博客根目录下新建 deploy.sh ，添加以下内容： #!/bin/bashecho \"Start\"hexo cleanhexo generategulphexo deployecho \"Finish\"echo 按任意键继续read -n 1然后每次部署就可以直接运行这个脚本了。","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://snow.js.org/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://snow.js.org/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://snow.js.org/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Gulp","slug":"gulp","permalink":"https://snow.js.org/tags/gulp/"},{"name":"PWA","slug":"pwa","permalink":"https://snow.js.org/tags/pwa/"},{"name":"应用程序","slug":"应用程序","permalink":"https://snow.js.org/tags/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"name":"部署","slug":"部署","permalink":"https://snow.js.org/tags/%E9%83%A8%E7%BD%B2/"}]},{"title":"简单数论","slug":"简单数论","date":"2020-08-03T16:00:00.000Z","updated":"2021-01-19T00:42:42.357Z","comments":true,"path":"num-theory/","link":"","permalink":"https://snow.js.org/num-theory/","excerpt":"","text":"# 简单数论 一点都不简单 # 欧几里得算法 又称辗转相除法 迭代求两数 gcd 的做法 由 (a,b)=(a,ka+b)(a, b) = (a, ka + b)(a,b)=(a,ka+b) 的性质：gcd⁡(a,b)=gcd⁡(b,a mod b)\\gcd(a, b) = \\gcd(b, a\\bmod b)gcd(a,b)=gcd(b,amodb) 容易证明这么做的复杂度是 O(log⁡n)O(\\log n)O(logn) 注意：gcd⁡(0,a)=a\\gcd(0, a) = agcd(0,a)=a # 裴蜀定理 设 (a, b) = d，则对任意整数 x, y，有 d|(ax + by) 成立； 特别地，一定存在 x, y 满足 ax + by = d 等价的表述：不定方程 ax + by = c (a, b, c 为整数) 有解的充要条件为 (a, b)|c 推论：a, b 互质等价于 ax + by = 1 有解 # P4549 【模板】裴蜀定理 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;algorithm>using namespace std;int main() &#123; int n; scanf(\"%d\", &amp;n); int a; scanf(\"%d\", &amp;a); int g = a; for(int i=2; i&lt;=n; ++i) &#123; scanf(\"%d\", &amp;a); if(a == 0) continue; if(a &lt; 0) a = -a; g = __gcd(g, a); &#125; printf(\"%d\\n\", g); return 0;&#125;# 扩展欧几里得 考虑如何求得 ax + by = d 的一个解。这里 d = (a, b) 考虑使用欧几里德算法的思想，令 a = bq + r，其中 r = a mod b； 递归求出 bx + ry = d 的一个解。 设求出 bx + ry = d 的一个解为 x = x0, y = y0，考虑如何把它变形成 ax + by = d 的解。 将 a = bq + r 代入 ax + by = d，化简得 b (xq + y) + rx = d 我们令 xq + y = x0, x = y0，则上式成立 故 x = y0, y = x0 - y0q 为 ax + by = d 的解 边界情况：b = 0 时，令 x = 1, y = 0 # P1082 同余方程 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;typedef long long ll;typedef pair&lt;ll, ll> pll;ll a, b;pll exgcd(ll a, ll b) &#123; if(b == 0) return &#123;1,0&#125;; pll p = exgcd(b, a%b); return &#123;p.second, p.first-a/b*p.second&#125;;&#125;int main() &#123; scanf(\"%lld%lld\", &amp;a, &amp;b); ll x = exgcd(a,b).first; while(x &lt; 0) x+=b; while(x-b > 0) x-=b; printf(\"%lld\\n\", x); return 0;&#125;# 求不定方程所有解 怎么求 ax + by = c 的所有解？ 先用 exgcd 求出任意一个解 x = x0, y = y0 再求出 ax + by = 0 的最小的解 x = dx = b/(a, b), y = dy = -a/(a, b) 所有解就是 x = x0 + kdx, y = y0 + kdy, k 取任意整数 # 逆元 若 ax ≡ 1 (mod b)，则称 x 是 a 关于模 b 的逆元， 常记做 a−1。 回忆同余的性质。上式等价于 ax + by = 1 如何求逆元？等价于解方程 ax + by = 1 因此逆元不一定存在： 存在的充要条件为 (a, b) = 1 推论：p 是质数，p 不整除 a，则 a 模 p 的逆元存在。 结论：在 [0, b) 的范围内，a 关于模 b 的逆元 (若存在) 是唯一的。 证明： 反证法，若 a 有两个逆元 0 &lt; x1 &lt; x2 &lt; b， 即 ax1 ≡ ax2 ≡ 1 (mod b)， 那么有 b|a (x2 − x1) 成立 又由于 (a, b) = 1，因此 b|(x2 − x1)。 其中 0 &lt; x2 − x1 &lt; b，产生了矛盾。 # P3811 【模板】乘法逆元 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;long long inv[int(3e6+10)]; int n, p;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;p); inv[1] = 1; for(int i=2; i&lt;=n; ++i) &#123; inv[i] = p-(p/i)*inv[p%i]%p; &#125; for(int i=1; i&lt;=n; ++i) printf(\"%lld\\n\", inv[i]); return 0;&#125;# 中国剩余定理 咕咕咕 # 杂题 如果看第一眼不会做，一般就得想一年的题，如臭名昭著的小凯类数论问题 # P4942 小凯的数字 我们知道，一个数模 9 等于他的各位和模 9。这一结论可以推广至将某数截成若干节，每段合起来也符合这个规律，题目便转化成求 sigma [l..r]。用 __int128 也可以过，但是更好是把除以二挪到前面，使其符合乘法取模分配率，注意奇偶。 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;typedef long long LL;int a[15], b[15];int main() &#123; int q; scanf(\"%d\", &amp;q); for(int i=1; i&lt;=q; ++i) &#123; LL l, r; scanf(\"%lld%lld\", &amp;l, &amp;r); if((r-l+1) %2 == 0) printf(\"%lld\\n\", ((r-l+1)/2)%9*(l+r)%9); else printf(\"%lld\\n\", ((l+r)/2)%9*(r-l+1)%9); &#125; return 0;&#125;# 整除分块 与其说整除分块是一种算法，不如说它是一个技巧。有时我们需要计算这样的式子： ∑i=1nf(i)⌊ni⌋\\sum_{i=1}^n f(i)\\lfloor\\frac{n}{i}\\rfloor i=1∑n​f(i)⌊in​⌋ 根据经验，我们发现 ⌊ni⌋\\lfloor\\frac{n}{i}\\rfloor⌊in​⌋ 只有 O(n)O(\\sqrt n)O(n​) 种取值。对于每种取值，i 都会有一个连续的范围。假设函数 f 的前缀和可以预处理后快速求出，那么我们可以枚举 ⌊ni⌋\\lfloor\\frac{n}{i}\\rfloor⌊in​⌋ 的所有取值，并和 f 的连续一段的和相乘。具体可以见代码： //s [i] 为函数 f (i) 的前缀和 int ans = 0;for(int i=1, j; i&lt;=n; i=j+1) &#123; j = n/(n/i); ans += (s[j]-s[i-1])*(n/i);&#125;printf(\"%d\\n\", ans);","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://snow.js.org/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"图论","slug":"图论","date":"2020-07-30T16:00:00.000Z","updated":"2021-01-19T00:42:42.358Z","comments":true,"path":"graph-theory/","link":"","permalink":"https://snow.js.org/graph-theory/","excerpt":"","text":"# 图论 图论算法一般都是揉在一起的，很难单独把算法拆开讲，所以直接上题目吧。分类是大致分的，其实有很多是交叉的。 # 二叉树 二叉树的遍历有三种，分别为前序遍历，中序遍历和后序遍历，并且给定其中的两种遍历能够求出另一种遍历 (必须已知中序遍历)。 前序遍历：按 根 左 右 的顺序进行； 中序遍历：按 左 根 右 的顺序进行； 后序遍历：按 左 右 根 的顺序进行。 # 最短路 &amp; 生成树 # 算法复杂度 多源最短路 Floyd：严格 O(n3)O(n^3)O(n3) 单源最短路 Dijkstra： 朴素：严格 O(n2)O(n^2)O(n2) 优先队列优化：均摊 O((e+n)log⁡n)O((e+n) \\log n)O((e+n)logn) Bellman-Ford： 最多松弛 n−1n-1n−1 次 严格 O(ne)O(ne)O(ne) SPFA： 即队列优化 Bellman-Ford 最坏 O(ne)O(ne)O(ne)，最好 O(1)O(1)O(1) # 板子 咕咕咕 # 如何卡掉 SPFA 见 https://www.zhihu.com/question/292283275/answer/484871888 # P1967 货车运输 最大生成树，然后跑 LCA #include &lt;cstdio>#include &lt;cstring>#include &lt;iostream>#include &lt;algorithm>using namespace std;const int N = 1e4+10, M = 1e5+10, INF = 0x3f3f3f3f;struct node &#123; int id, u, v, w, next;&#125; e[M], e1[M];int h[N], tot = 0, tot1 = 0, n, m;int fa[N][15], dep[N], dis[N][15];int vis[N];bool edg[M];void add(int u, int v, int w) &#123; e1[tot1] = e[tot] = &#123;tot, u, v, w, h[u]&#125;; h[u] = tot++; tot1++; e[tot] = &#123;tot, v, u, w, h[v]&#125;; h[v] = tot++;&#125;int bc[N];int root(int u) &#123; return bc[u] == u ? u : bc[u] = root(bc[u]);&#125;bool cmp(node a, node b) &#123; return a.w > b.w;&#125;void dfs(int u, int f, int vi) &#123; vis[u] = vi; for(int i = h[u]; i != -1; i = e[i].next) &#123; int v = e[i].v; if(v == f) continue; if(edg[i] or edg[i^1]) &#123; dep[v] = dep[u] + 1; fa[v][0] = u; dis[v][0] = e[i].w; dfs(v, u, vi); &#125; &#125;&#125;void lca(int x, int y) &#123; if(dep[x] &lt; dep[y]) swap(x, y); int ans = INF; int t = dep[x] - dep[y]; for(int i=14; i>=0; --i) &#123; if(t >= (1&lt;&lt;i)) &#123; ans = min(ans, dis[x][i]); x = fa[x][i]; t -= (1&lt;&lt;i); &#125; &#125; if(x == y) &#123; printf(\"%d\\n\", ans); return; &#125; for(int i=14; i>=0; --i) &#123; if(fa[x][i] != fa[y][i]) &#123; ans = min(ans, dis[x][i]); ans = min(ans, dis[y][i]); x = fa[x][i]; y = fa[y][i]; &#125; &#125; //printf(\"lca:%d\\n\", fa[x][0]); printf(\"%d\\n\", min(ans, min(dis[x][0], dis[y][0])));&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(h, -1, sizeof h); for(int i=1; i&lt;=m; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); add(u, v, w); &#125; sort(e1, e1+tot1, cmp); for(int i=1; i&lt;=n; ++i) bc[i] = i; for(int i=0; i&lt;tot1; ++i) &#123; int u = e1[i].u, v = e1[i].v; int u1 = root(u), v1 = root(v); if(u1 != v1) &#123; edg[e1[i].id] = true; bc[v1] = u1; &#125; &#125; for(int i=1; i&lt;=n; ++i) &#123; if(bc[i] == i) &#123; dfs(i, 0, i); for(int j=0; j&lt;=14; ++j) &#123; fa[i][j] = i; dis[i][j] = INF; &#125; &#125; &#125; for(int i=1; i&lt;=14; ++i) &#123; for(int j=1; j&lt;=n; ++j) &#123; fa[j][i] = fa[fa[j][i-1]][i-1]; dis[j][i] = min(dis[j][i-1], dis[fa[j][i-1]][i-1]); &#125; &#125; int query; scanf(\"%d\", &amp;query); for(int i=1; i&lt;=query; ++i) &#123; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); if(vis[x] != vis[y]) &#123; printf(\"-1\\n\"); continue; &#125; lca(x, y); &#125; return 0;&#125;# P1073 最优贸易 分层图，最短路 #include &lt;stdio.h>#include &lt;string.h>#include &lt;limits.h>#include &lt;iostream>#include &lt;queue>#include &lt;map>using namespace std;const int N = 330000, M = 1650000;struct node &#123; int u, v, w, next; node() &#123;&#125; node(int _u, int _v, int _w, int _next): u(_u), v(_v), w(_w), next(_next) &#123;&#125;&#125; e[M &lt;&lt; 1];int h[N], tot = 0;inline void add(int u, int v, int w = 0) &#123; e[tot] = node(u, v, w, h[u]); h[u] = tot++;&#125;int n, m, w[N]; bool vis[N]; int dis[N];int main() &#123; #ifdef DEBUG freopen(\"p1073_1.in\", \"r\", stdin); #endif scanf(\"%d%d\", &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) &#123; scanf(\"%d\", &amp;w[i]); &#125; memset(h, -1, sizeof h); for(int i=1, x, y, z; i&lt;=m; ++i) &#123; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); if(z == 1) add(x, y), add(x+n, y+n), add(x+2*n, y+2*n); else &#123; add(x, y), add(x+n, y+n), add(x+2*n, y+2*n); swap(x, y); add(x, y), add(x+n, y+n), add(x+2*n, y+2*n); &#125; &#125; for(int i=1; i&lt;=n; ++i) &#123; add(i+n, i, w[i]); add(i, i+2*n, -w[i]); &#125; queue&lt;int> q; memset(dis, 0x3f, sizeof dis); q.push(n+1); vis[n+1] = true; dis[n+1] = 0; while(!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for(int i=h[u]; i!=-1; i=e[i].next) &#123; int v=e[i].v; if(dis[v] > dis[u] + e[i].w) &#123; dis[v] = dis[u] + e[i].w; if(!vis[v]) &#123; q.push(v); vis[v] = true; &#125; &#125; &#125; &#125; printf(\"%d\\n\", -dis[n*3]); return 0;&#125;# P1119 灾后重建 很重要的题目，考察了 Floyd 的本质。 # Floyd 用 dis[k][i][j]dis[k][i][j]dis[k][i][j] 表示 i 和 j 之间可以通过编号为 1…k1\\dots k1…k 的节点的最短路径，显然，dis[0][i][j]dis[0][i][j]dis[0][i][j] 就是原始邻接矩阵数据。 状态转移方程： dis[k][i][j]=min(dis[k−1][i][j],dis[k−1][i][k]+dis[k−1][k][j])dis[k][i][j]=min(dis[k-1][i][j],dis[k-1][i][k]+dis[k-1][k][j]) dis[k][i][j]=min(dis[k−1][i][j],dis[k−1][i][k]+dis[k−1][k][j]) Floyd 的本质其实就是 DP，只不过我们通常做题时利用了数据只会使用一次性的原理，把 dis 变成滚动数组，减少了一维，节省空间。 更多请见 https://www.cnblogs.com/fangwencai/p/4784914.html。 // 提前将邻接矩阵存在 dis 数组里，其他不连通的地方初始化成无穷大for(int k=1; k&lt;=n; ++k) // 枚举中间点 for(int i=1; i&lt;=n; ++i) // 枚举起点 if(i != k) // 节省时间，如果一样就不往下走 for(int j=1; j&lt;=n; ++j) // 枚举终点 if(i != j and j != k) // 继续判断，如果有一样的就不往下走 dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); // 状态转移方程，也就是所谓的松弛操作只要我们能够利用 DP 特性，就能解决许多问题 再回来看这道题，文中说每个村子是不同时间修好的，而每个节点都按顺序给出，这不就是恰好相当于 Floyd 的中间点吗？我们可以把 k 轮 DP 分开做，每输入一个点，就用这个点当中转站把最短距离更新一遍，也就是跑一遍 DP。 # Code: #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;algorithm>using namespace std;const int N = 220;int t[N];struct query &#123; int id, x, y, t;&#125; a[55000];int res[55000], n, m, dp[N][N];int main() &#123; //freopen(\"P1119_2.in\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) &#123; scanf(\"%d\", t+i); &#125; t[n+1] = 0x3f3f3f3f; memset(dp, 0x3f, sizeof dp); for(int i=1; i&lt;=n; ++i) dp[i][i] = 0; for(int i=1; i&lt;=m; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); ++u, ++v; dp[u][v] = dp[v][u] = w; &#125; int q; scanf(\"%d\", &amp;q); for(int i=1; i&lt;=q; ++i) &#123; scanf(\"%d%d%d\", &amp;a[i].x, &amp;a[i].y, &amp;a[i].t); a[i].id = i; ++a[i].x, ++a[i].y; &#125; int cnt = 1; for(; a[cnt].t &lt; t[1]; ++cnt) &#123; res[a[cnt].id] = -1; &#125; for(int T=1; T&lt;=n; ++T) &#123; for(int i=1; i&lt;=n; ++i) &#123; for(int j=1; j&lt;=n; ++j) &#123; dp[i][j] = min(dp[i][j], dp[i][T] + dp[T][j]); &#125; &#125; while(1) &#123; if(cnt > q) break; if(a[cnt].t >= t[T] and a[cnt].t &lt; t[T+1]); else break; if(a[cnt].x > T or a[cnt].y > T or dp[a[cnt].x][a[cnt].y] == 0x3f3f3f3f) &#123; res[a[cnt].id] = -1; &#125; else &#123; res[a[cnt].id] = dp[a[cnt].x][a[cnt].y]; &#125; ++cnt; &#125; &#125; for(int i=1; i&lt;=q; ++i) printf(\"%d\\n\", res[i]); return 0;&#125;# 判负环 转自 @SingerCoder，% lgh 注意一定要判入队次数而不是松弛次数。 hack 原理很简单：如果存在重边导致了多次松弛，那么对松弛次数的判断就会产生影响。解决方式就是判入队次数，虽然略慢，但是更稳。 Update [2020.7.26]：在写差分约束的时候想用 spfa 判无解，然后经过一系列的思考就有了下面这组新的 hack 数据： input: 1 4 6 1 2 -3 1 3 -2 1 4 -1 2 3 -6 2 4 -5 3 4 -4 output: NO 注意这组 hack 只对用链式前向星（而非 vector）存边且判的是松弛次数（而非入队次数）的有效，而且该数据无重边无自环，比 discuss 里面的那个数据更有说服力。 首先 hack 原理就是对 n 号节点进行 n-1 轮松弛，每轮都有 x(x∈[1,n−1])x( x \\in [1,n-1])x(x∈[1,n−1]) 次松弛，这样就能产生 n2n^2n2 级别的松弛次数。 但是判入队次数就 hack 不掉了，每轮的第一次松弛会让 n 节点入队，但 n 节点只有在下一轮才会出队；因此本轮的其余所有松弛全部无法导致入队。 # P3385 [模板] 负环 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;queue>using namespace std;const int N = 2e3 + 10, M = 6e3 + 10;struct node &#123; int u, v, w, next;&#125; e[M];int h[N], tot = 0;int T, n, m;inline void add(int u, int v, int w) &#123; e[++tot] = &#123;u, v, w, h[u]&#125;; h[u] = tot;&#125; int dis[N], vis[N];bool inq[N];inline void spfa() &#123; queue&lt;int> q; memset(dis, 0x3f, sizeof dis); memset(vis, 0, sizeof vis); memset(inq, false, sizeof inq); dis[1] = 0; q.push(1); inq[1] = true; ++vis[1]; while(!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false;//printf(\"%d\\n\", u); for(int i = h[u]; i ; i = e[i].next) &#123; int v = e[i].v; if(dis[v] > dis[u] + e[i].w) &#123; dis[v] = dis[u] + e[i].w; if(!inq[v]) &#123; inq[v] = true; ++vis[v]; if(vis[v] > n-1) &#123; printf(\"YES\\n\"); return; &#125; q.push(v); &#125; &#125; &#125; &#125; printf(\"NO\\n\");&#125;int main() &#123; //freopen(\"P3385_2.in\", \"r\", stdin); scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(h, 0, sizeof h); tot = 0; for(int i=1; i&lt;=m; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); if(w >= 0) &#123; add(u, v, w); add(v, u, w); &#125; else add(u, v, w); //printf(\"%d \", i); &#125; spfa(); &#125; return 0;&#125;# 基环树 n 个点 n 条边 只有一个环 枚举断边 # P5022 [NOIp2018TG] 旅行","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://snow.js.org/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","permalink":"https://snow.js.org/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"Hexo：配置 SSH 公钥部署","slug":"Hexo：配置SSH公钥部署","date":"2020-07-22T16:00:00.000Z","updated":"2021-01-19T00:42:42.359Z","comments":true,"path":"hexo-ssh-deploy/","link":"","permalink":"https://snow.js.org/hexo-ssh-deploy/","excerpt":"","text":"# Hexo：配置 SSH 公钥部署 # 配置 git 使用 ssh 密钥 git 支持 https 和 git 两种传输协议。其实两种方式都可以，但是如果使用 https 协议，每次 pull、push 都要输入密码（大部分电脑上），所以建议使用 ssh 密钥对认证，可实现免密且更加安全。下面将介绍 Hexo 如何配置 SSH 公钥部署。 示例在 Windows 环境下。 # Step 1：生成密钥对 - 进入 C:\\用户\\[你的用户名]/.ssh 文件夹，右键唤出 PowerShell - 输入 ssh-keygen ，并一直敲击回车至密钥图生成，可以看到文件夹中多出了两个文件： id_rsa 和 id_rsa.pub 实例： SerokSSR@Desktop-ABCDEFG ~\\.ssh> ssh-keygen Generating public/private rsa key pair.Enter file in which to save the key (C:\\Users\\SerokSSR/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in C:\\Users\\SerokSSR/.ssh/id_rsa.Your public key has been saved in C:\\Users\\SerokSSR/.ssh/id_rsa.pub.The key fingerprint is:SHA256:fO7pVFqZ464nC8H6B3pTE8cwPx2mTM0G8KJt7Or2L8o SerokSSR@DESKTOP-ABCDEFGThe keys randomart image is:+---[RSA 2048]----+| ...+ || o.. * || .B.= . || o +..Bo. || S =o*. || ..*o= . || ...o=.. || .o+=+o. || +E*BBo |+----[SHA256]-----+# Step 2：配置远程仓库的公钥 - 访问 GitHub，点击 头像 -&gt; Settings -&gt; 左侧 SSH and GPG keys -&gt; 右上 New SSH key - 打开你刚才生成的 /.ssh/id_rsa.pub ，把里面的内容全选复制到 Key 栏中，Title 栏可不填 - 点击 Add SSH key，完成添加 # Step 3：验证密钥是否生效 控制台输入 ssh -T git@github.com ，出现如下回复则密钥已生效。 SerokSSR@DESKTOP-ABCDEFG ~\\.ssh> ssh -T git@github.comHi SerokSSR! Youve successfully authenticated, but GitHub does not provide shell access.# Step 4：添加 SSH 仓库 在你的博客根目录下的 _config.yml ，找到 deploy 选项，将你仓库的 ssh 链接添加至此处。 实例： deploy:- type: git repo: git@github.com:SerokSSR/snow.git branch: master# Step 5：配置 Hexo 部署 为了方便每次部署，可以在你的博客根目录下新建 deploy.sh ，添加以下内容： #!echo \"Start\"hexo cleanhexo generatehexo deployecho \"Finish\"echo 按任意键继续read -n 1然后每次部署就可以直接运行这个脚本，而不用每次都要敲一遍 hexo cl&amp;&amp;hexo g&amp;&amp;hexo d 了。","categories":[{"name":"Hexo","slug":"hexo","permalink":"https://snow.js.org/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://snow.js.org/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://snow.js.org/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"部署","slug":"部署","permalink":"https://snow.js.org/tags/%E9%83%A8%E7%BD%B2/"},{"name":"SSH","slug":"ssh","permalink":"https://snow.js.org/tags/ssh/"},{"name":"GitHub","slug":"github","permalink":"https://snow.js.org/tags/github/"}]},{"title":"涉江","slug":"涉江","date":"2020-06-22T16:00:00.000Z","updated":"2021-01-19T00:42:42.358Z","comments":true,"path":"she-jiang/","link":"","permalink":"https://snow.js.org/she-jiang/","excerpt":"","text":"# 涉江 E 座的尽头是一扇窗。她喜欢伏在那里的窗棂上，很多个课间。窗外是一幢天井；三面环楼，夐不见曦。 天井的中央是一台鱼池。一到每年新生入学的时候，鱼们便如笋般冒了出来，流水潺潺，清荣峻茂；整个学校也像鱼池一样变得活络了起来。人们的脸上总是挂着笑容；鱼池旁也缀上了很多人影，来来往往的。 她的背后是一道走廊，连结着初中部和高一年级。原则上，高一的饮水机坏了，才会有人从这里经过，就比如这几天；那边的机器更高端，相传有四个水龙头。她听高三的学长们说，原先这里本是熙熙攘攘，那一年却突然间就变了天。或许今后也会有那一年吧。走廊里时常有行为艺术家们走过，小嘴抹蜜，应节而舞，免不了一群男女从旁指点，逼逼赖赖。也有三三两两的女生们，攒聚喁喁。偶尔天亮的时候，也会有许多男同，两两联会，而姐妹相称。 但这些都与她无关。她相信未来，相信辰星在无边的旷野，正如大多数人一样。她可能还没有想到过那样的一天，雪花浸满了每一个角落。空自，她守望着梦乡。 楼下有一群人走过，为首的迨着球。教室里传来九日的声响。他似乎看见了她。她的思绪仍然飘在远方，漠然颔首。 他们走上楼来。他一迳向 E 座的尽头走去。值勤的女生认出了他，嘴唇微微动了动，遽把脸扭了过去，没有作声。他也照着做了。那扇窗静静地在那里；窗闩没有扣严，被一阵狂风吹散了。他正要上前，风却一瞬间弱了下去。太阳拐了一个弯；和煦的光洒遍了他和她的窗。微风摩挲着窗扇，像一只系在法线上的蝴蝶。 她和他站在那里，看着归帆迤逦着向远方飘散。日光投靠在他的身侧，渲染出几许明媚的景致来，蹦跳着走远了。水波轻轻地颤动着。月亮干咳了几下，发出沙沙的响声，挑达在城阙上。兰麝香仍在，珮环声渐远。 success 未完待续","categories":[{"name":"小说 & 随笔","slug":"hitokoto","permalink":"https://snow.js.org/categories/hitokoto/"},{"name":"陌上","slug":"hitokoto/陌上","permalink":"https://snow.js.org/categories/hitokoto/%E9%99%8C%E4%B8%8A/"}],"tags":[{"name":"小说","slug":"小说","permalink":"https://snow.js.org/tags/%E5%B0%8F%E8%AF%B4/"}]},{"title":"还在用 STL 排序？","slug":"还在用 STL 排序？","date":"2020-06-19T16:00:00.000Z","updated":"2021-01-19T00:42:42.358Z","comments":true,"path":"still-using-stl-sort/","link":"","permalink":"https://snow.js.org/still-using-stl-sort/","excerpt":"","text":"还在用 STL 排序？ # 使用 C 库函数 很多人都不知道的是，其实 C 语言也是自带排序函数的，就是位于 &lt;stdlib.h&gt; 库中的 qsort 函数声明： void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))其中 base - 指向要排序的数组的第一个元素的指针 nitems - base 指向的数组中元素的个数 size - 数组中每个元素的大小（以字节为单位） compar - 用来比较两个元素的函数 与 &lt;algorithm&gt; 中的 std::sort 略有差异，尤其是在 compar 函数的定义上。 其形参必须是 const void* 型（可以理解为，在 compar 函数内部会将 const void* 型转换成实际类型）。 如果返回值小于 0（&lt; 0），那么 p1 所指向元素会被排在 p2 所指向元素的左面； 如果返回值等于 0（= 0），那么 p1 所指向元素与 p2 所指向元素的顺序不确定； 如果返回值大于 0（&gt; 0），那么 p1 所指向元素会被排在 p2 所指向元素的右面。 在 C11 标准中，新增了另一个排序函数 qsort_s ，但在无编译开关的情况下无法使用。 另外，虽然它的名字叫 qsort ，但目前还没有任何一个 C 标准规定其必须通过快排实现（） 实测在整数排序下，效率与 STL 相差无几，都在 140ms/1.20MB 左右。 Code (C) : #include &lt;stdio.h>#include &lt;stdlib.h>const int N = 1e5 + 10;int cmp(const void *a, const void *b) &#123; return (*(int*)a - *(int*)b);&#125;int main() &#123; int n, i, a[N]; scanf(\"%d\", &amp;n); for (i=0; i&lt;n; ++i) scanf(\"%d\", a+i); qsort(a, n, sizeof(int), cmp); for (i=0; i&lt;n-1; ++i) printf(\"%d \", a[i]); printf(\"%d\\n\", a[n-1]); return 0;&#125;# 使用 PB_DS PB_DS ，又称平板电视，是一个冷门但功能极为强大的 GNU-cpp 扩展库，但在 OI 中（尤其是省选以下）极少用到。 该库中提供了大量数据结构（虽然不开 O2 的话几乎都会 T 掉），以树形结构为主，拿出来基本个个都可以排序 堆： （未开 O2， 248ms/5.23MB ） #include &lt;bits/stdc++.h>#include &lt;bits/extc++.h>using namespace std;using namespace __gnu_pbds;__gnu_pbds::priority_queue &lt; int, greater&lt;int>, pairing_heap_tag > q;int n;int main() &#123; scanf(\"%d\", &amp;n); for(int i=0, a; i&lt;n; ++i) scanf(\"%d\", &amp;a), q.push(a); for(int i=0; i&lt;n; ++i) printf(\"%d \", q.top()), q.pop(); return 0;&#125;由于 pb_ds 中的 tree 相当于 set 而不是 multiset ，因此比手写快排还长，不再展示。","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://snow.js.org/tags/%E6%8E%92%E5%BA%8F/"},{"name":"STL","slug":"stl","permalink":"https://snow.js.org/tags/stl/"},{"name":"PB_DS","slug":"pb-ds","permalink":"https://snow.js.org/tags/pb-ds/"}]},{"title":"网络流：最大流","slug":"网络流：最大流","date":"2020-05-13T16:00:00.000Z","updated":"2021-01-19T00:42:42.357Z","comments":true,"path":"maximum-flow/","link":"","permalink":"https://snow.js.org/maximum-flow/","excerpt":"","text":"# 网络流：最大流 # EK 增广路方法是很多网络流算法的基础。其思路是每次找出一条从源到汇的能够增加流的路径，调整流值和残留网络 ，直到没有增广路为止。 EK 算法就是不断的找最短路，找的方法就是每次找一条边数最少的增广（即最短路径增广）。 # 最多要增广多少次？ 可以证明，最多 O (VE)​ 次增广，可以达到最大流。 # 如何找到一条增广路？ 先明确什么是增广路。增广路是一条从 s 到 t 的路径，路径上每条边残留容量都为正。把残留容量为正的边设为可行的边，那么我们就可以用简单的 BFS 得到边数最少的增广路。 # 如何增广？ BFS 得到增广路之后，这条增广路能够增广的流值，是路径上最小残留容量边决定的。把这个最小残留容量 MinCap 值加到最大流值 Flow 上，同时路径上每条边的残留容量值减去 MinCap；最后，路径上每条边的反向边残留容量值要加上 MinCap。这样每次增广的复杂度为 O(E)，总复杂度就是 O(VE2)。事实上，大多数网络的增广次数很少，因此 EK 算法能处理绝大多数问题。 # 为什么增广路径上每条边的反向边残留容量值要加上 MinCap？ 残留网络 = 容量网络 - 流量网络 容量网络不改变的情况下，由于增广好比给增广路上通了一条流，路径上所有边流量加 MinCap 之后，相对应的残留网络就发生相反的改变。因为建立了反向边，如果这条路径不是最理想的就会回流，避免了这种情况。这是网络流里很重要的一点。 # 图例 # Dinic # BFS 分层 与 EK 一样，我们仍要通过 bfs 来判断图中是否还存在增广路，但是 Dinic 算法里的 bfs 略有不同。这次，我们不用记录路径，而是给每一个点分层，对于任意点 i，从 s 到 i 每多走过一个点，就让层数多 1。一次分层后可以找到多条增广路，从而提高效率。 分完层效果是这样的：（蓝色的数字是每个点层数） # DFS 增广 有了每个点的层数编号，对任意点 u 到点 d 的路径如果有 dep[d]=dep[u]+1dep[d]=dep[u]+1dep[d]=dep[u]+1，我们就可以判断该路径在增广路上。 比如说，我们首先找 s-&gt;1-&gt;4-&gt;t： 第二次，s-&gt;1-&gt;5-&gt;t： 第三次，s-&gt;1-&gt;3-&gt;t： 还有第四条，s-&gt;2-&gt;3-&gt;t： PS：Dinic 在跑二分图匹配时比匈牙利快很多。 # P3376 网络最大流 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;queue>using namespace std;const int N = 11000, M = 110000;const int INF = 0x7fffffff;struct node &#123; int u, v, w, next;&#125; e[M &lt;&lt; 1];int cur[N], h[N], tot;int dfn[N], ans, n, m, s, t;void add(int u, int v, int w) &#123; e[tot] = node(&#123;u, v, w, h[u]&#125;); cur[u] = h[u] = tot++;&#125;bool bfs() &#123; memcpy(cur, h, sizeof cur); memset(dfn, 0, sizeof dfn); queue&lt;int> q; dfn[s] = 1; q.push(s); while(!q.empty()) &#123; int u = q.front(); q.pop(); for(int i = h[u]; i != -1; i = e[i].next) &#123; int v = e[i].v; if(e[i].w and !dfn[v]) &#123; dfn[v] = dfn[u] + 1; q.push(v); if(v == t) return true; &#125; &#125; &#125; return false;&#125;int dfs(int u, int low) &#123; if(u == t) return low; int w = low; for(int i = cur[u]; i != -1; i = e[i].next) &#123; int v = e[i].v; cur[u] = i; if(e[i].w and dfn[v] == dfn[u] + 1) &#123; int f = dfs(v, min(w, e[i].w)); if(f == 0) dfn[v] = 0; e[i].w -= f; e[i^1].w += f; w -= f; if(!w) break; &#125; &#125; return low - w;&#125;void dinic() &#123; int flow; while(bfs()) while(flow = dfs(s, INF)) ans += flow;&#125;int main() &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;s, &amp;t); memset(h, -1, sizeof h); for(int i=1, u, v, w; i&lt;=m; ++i) &#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, 0); &#125; dinic(); printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"},{"name":"网络流","slug":"algorithm/network-flow","permalink":"https://snow.js.org/categories/algorithm/network-flow/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"网络流","slug":"网络流","permalink":"https://snow.js.org/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"网络流：最小割","slug":"网络流：最小割","date":"2020-05-13T16:00:00.000Z","updated":"2021-01-19T00:42:42.357Z","comments":true,"path":"minimum-cut/","link":"","permalink":"https://snow.js.org/minimum-cut/","excerpt":"","text":"# 网络流：最小割 将图 GGG 分为 AAA 和 BBB 两个点集，AAA 和 BBB 之间的边的集合称为无向图的割集。带权图的割 (Cut) 就是割集中的边权之和。 # S - T 最小割 特别地，对于一个网络，在满足 源点s∈点集{S},汇点t∈点集{T}(S∩T=∅)源点 s \\in 点集\\{S\\}, 汇点 t \\in 点集\\{T\\}(S\\cap T= \\varnothing)源点s∈点集{S},汇点t∈点集{T}(S∩T=∅) 的情况下，从 S 到 T 的边的权值和被称为 S 到 T 的割。 通俗地说，如果把你家和自来水厂之间的水管网络砍断了一些，那么自来水厂无论怎么放水，水都无法到达你们家，自然就停水了，砍掉的水管就是割。 砍水管的人自然希望花的力气越小越好。在所有割中，权值和最小的称为最小割。对于一个给定的 S - T 网络，如何求出它的最小割呢？ # 最大流最小割定理 网络的最大流等于最小割。 这个定理看起来很简单，但是真去思考的话其实是很麻烦的。 # 证明 Step 1：任意一个流都小于等于任意一个割 自来水公司随便给你家通点水，构成一个流，随便砍几刀砍出一个割，那么由于容量限制，每一根的被砍的水管子流出的水流量都小于管子的容量。每一根被砍的水管的水本来都要到你家的，现在流到外面，加起来得到的流量还是等于原来的流。而管子的容量加起来就是割，所以流小于等于割。 由于上面的流和割都是任意构造的，所以任意一个流小于任意一个割，即 ∀F⩽∀C\\forall F \\leqslant \\forall C ∀F⩽∀C # Step 2：构造出一个流，使它等于一个割 当达到最大流时，根据增广路定理，残留网络中 s 到 t 已经没有通路了。因此，若把残余网络中 s 能到的的点的集合设为 S，不能到的点集为 T ，构造出一个割集 C[点集S,点集T]C[点集S,点集T]C[点集S,点集T]，所有由 S 发往 T 的边必然满流。并且，这些满流边的流量和就是当前的流，即最大流。把这些满流边作为割，就构造出了一个和最大流相等的割。 # Step 3：最大流等于最小割 设上一步构造出流和割分别为 FmF_mFm​ 和 CmC_mCm​。 又 ∀F⩽∀C\\forall F \\leqslant \\forall C∀F⩽∀C ∴∀F⩽Fm=Cm⩽∀C\\therefore \\forall F \\leqslant F_m=C_m \\leqslant \\forall C∴∀F⩽Fm​=Cm​⩽∀C。 # 网络流等价定理 （这个名字是我自己想的 综合最大流最小割定理和增广路定理，可以得到这样的结论： 对于一个网络流图 G=(V,E)G=(V,E)G=(V,E)，其中有源点 sss 和汇点 ttt ，那么下面三个条件是等价的： 流 fff 是图 GGG 的最大流； 残留网络 GGG 不存在增广路； 在 GGG 中必存在一个割 C[S,T]C[S,T]C[S,T]，使得 f=C[S,T]f=C[S,T]f=C[S,T]。 读者自证不难 # 证明 1 =&gt; 2（即增广路定理） 利用反证法，假设流 fff 是图 GGG 的最大流，但是残留网络中还存在有增广路 ppp，其流量为 fpf_pfp​，则有流 f′=f+fp&gt;ff&#x27;=f+f_p&gt;ff′=f+fp​&gt;f。这与 fff 是最大流产生矛盾。 # 证明 2 =&gt; 3（即最大流最小割定理） 总结一下上面的证明。 假设残留网络 GfG_fGf​ 不存在增广路，所以在残留网络 GfG_fGf​ 中不存在路径从 sss 到达 ttt。我们定义 SSS 集合为当前残留网络中 sss 能够到达的点，同时定义 T=V−ST=V-ST=V−S，此时构成一个割 C(S,T)C(S,T)C(S,T)。 且 u∈S,v∈Tu∈S,v∈Tu∈S,v∈T，有 f(u,v)=c(u,v)f(u,v)=c(u,v)f(u,v)=c(u,v)。若 f(u,v)&lt;c(u,v)f(u,v)&lt;c(u,v)f(u,v)&lt;c(u,v)，则有 Gf(u,v)&gt;0G_f(u,v)&gt;0Gf​(u,v)&gt;0，sss 可以到达 vvv，与 v∈Tv \\in Tv∈T 矛盾。 因此有 f(S,T)=∑f(u,v)=∑c(u,v)=C(S,T)f(S,T)= \\sum f(u,v)=\\sum c(u,v)=C(S,T)f(S,T)=∑f(u,v)=∑c(u,v)=C(S,T)。 # 证明 3 =&gt; 1： 由于 fff 的上界为最小割，当 fff 到达割的容量时，显然就已经到达最大值，因此 fff 为最大流。 这样就说明了为什么找不到增广路时，所求得的一定是最大流。 # 最大权闭合子图 在一个图中，我们选取一些点构成集合，记为 V，且集合中的出边（即集合中的点的向外连出的弧），所指向的终点也在 V 中，则我们称 V 为闭合图。在所有闭合图中，集合中点的权值之和最大的 V，称为最大权闭合子图。 # 栗子 上图中最大权闭合子图为 {3,4,5}。 # 最大权闭合子图权值和 # 构图 构建一个超级源点 s，一个超级汇点 t，所有的点按权值的正负连接到 s 和 t 上，转换成一个边权值有向图，如下图： （注：点权为 0 的点可以忽略，对结果没有影响） # 前置知识 该带边权有向图的 S - T 最小割，割集中所有的边，都与 s 或 t 相连接。 显然，因为不与 s,t 相连的边，权值都是 INF，最小割不可能割在 INF 的边上。 该图中的每一个简单割产生的两个子图，我们记含有点 s 的是图 S，含有点 t 的是图 T，则图 S 是最大权闭合子图。 简单割内不包含边权为 INF 的边，即不含有连通两个图的边（除了连接在 t 点上的边之外）；即，图 S 中没有边与图 T 连通，那么，所有的边都只能连接在图 S 之内，即为闭合图。 记割集中，所有连接在 s 上的边的权值和为 x1x_1x1​，所有连接在 t 上的边的权值和为 x2x_2x2​，则割集中所有边权值和为 x=x1+x2x=x_1+x_2x=x1​+x2​。 记图 S 中所有点的权值和为 www，记其中正权值之和为 w1w_1w1​，负权值之和为 −w2- w_2−w2​，故 w=w1−w2w = w_1 - w_2w=w1​−w2​。 因此， w+x=w1−w2+x1−x2w+x=w_1-w_2+x_1-x_2 w+x=w1​−w2​+x1​−x2​ 又 ， x2=w2x_2 = w_2 x2​=w2​ 因为图 S 中所有负权值的点必然连接到 t 点，而图 S 必然要与 t 分割开，故割集中，连接在 t 点上的边权值和就是图 S 中所有负权值点的权值之和取负。因而， w+x=w1+x1w+x=w_1+x_1 w+x=w1​+x1​ 显然，w1+x1w_1 + x_1w1​+x1​ 是整个图中所有正权值之和，记为 sumsumsum，则 w=sum−xw=sum-x w=sum−x 即，图 S 中所有点的权值和 = 整个图中所有正权值之和 - 割集中所有边权值和。因为 sumsumsum 为定值，只要我们取最小割，则图 S 中所有点的权值和就是最大的，即此时图 S 为最大权闭合子图。 # 栗子 # 解法 先记录整个图中，所有正点权值的和； 建立对应流网络，求最大流，最大流在数值上等于最小割，故我们得到了流网络的 s-t 最小割； 所有正点权值的和减去 s-t 最小割，即得最大权闭合子图的权值和。 # P2762 太空飞行计划问题 # Hint 这里大概讲一下转换成最大流以后怎么输出。 一个结论就是假如我们跑的是 Dinic 那么我们最后一次网络流（这一次网络流并没有起任何作用，只是确认了无更多残余流量可以退出了）中，所有被分到层的都一定被选上了。 没有更多残余流量其实意味着这个图已经被割成了两部分，一个实验如果有层数意味着它没有被割掉（被选上了），一个仪器如果有层数意味着它已经被割掉了（也是被选上了）。 于是只要在最后输出所有有层数的点就行了。 # Code #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;queue>using namespace std;const int N = 110, INF = 0x3f3f3f3f;char tools[10000];class node &#123; public: int u, v, w, next;&#125; e[N * N];int head[N], cur[N], tot = 0;void add(int u, int v, int w) &#123; e[tot] = &#123;u, v, w, head[u]&#125;; head[u] = tot++; e[tot] = &#123;v, u, 0, head[v]&#125;; head[v] = tot++;&#125;int h[N], n, m, s, t;bool bfs() &#123; memset(h, 0, sizeof h); memcpy(cur, head, sizeof cur); queue&lt;int> q; q.push(s); h[s] = 1; while(!q.empty()) &#123; int u = q.front(); q.pop(); for(int i = head[u]; i != -1; i = e[i].next) &#123; int v = e[i].v; if(e[i].w and h[v] == 0) &#123; h[v] = h[u] + 1; if(v == t) return true; q.push(v); &#125; &#125; &#125; return false;&#125;int dfs(int u, int low) &#123; if(u == t) return low; int w = low; for(int i = cur[u]; i != -1; i = e[i].next, cur[u] = i) &#123; int v = e[i].v; if(e[i].w and h[v] == h[u] + 1) &#123; int f = dfs(v, min(w, e[i].w)); if(f == 0) h[v] = 0; e[i].w -= f; e[i^1].w += f; w -= f; if(w == 0) break; &#125; &#125; return low - w;&#125;int maxflow = 0, sum = 0;void dinic() &#123; int flow; while(bfs()) while(flow = dfs(s, INF)) maxflow += flow;&#125;int main() &#123; //freopen(\"shut2.in\", \"r\", stdin); scanf(\"%d%d\", &amp;m, &amp;n); memset(head, -1, sizeof head); s = 0, t = n+m+1; for(int i=1, w; i&lt;=m; ++i) &#123; scanf(\"%d\", &amp;w); add(s, i, w); sum += w; memset(tools, '\\0', sizeof tools); cin.getline(tools, 10000); int ulen = 0, tool; while(sscanf(tools + ulen, \"%d\", &amp;tool) == 1) &#123; add(i, tool + m, INF); if(tool == 0) ulen++; else &#123; while(tool) &#123; tool /= 10; ulen++; &#125; &#125; ulen++; &#125; &#125; for(int i=1, w; i&lt;=n; ++i) &#123; scanf(\"%d\", &amp;w); add(i+m, t, w); &#125; dinic(); for(int i=1; i&lt;=m; ++i) if(h[i]) printf(\"%d \", i); printf(\"\\n\"); for(int i=1; i&lt;=n; ++i) if(h[i+m]) printf(\"%d \", i); printf(\"\\n\"); printf(\"%d\\n\", sum - maxflow); return 0;&#125;# 全局最小割 暂时留坑，可以先参考这篇文章。 # Code (POJ 2914, 未优化版) #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;const int N = 550;int g[N][N];int dis[N];bool flag[N], vis[N];int n, m, s, t;int main() &#123; while(scanf(\"%d%d\", &amp;n, &amp;m) != EOF) &#123; memset(g, 0, sizeof g); for(int i=1, a, b, c; i&lt;=m; ++i) &#123; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); ++a, ++b; g[a][b] += c; g[b][a] += c; &#125; int ans = 0x3f3f3f3f; memset(flag, false, sizeof flag); for(int o=1; o&lt;n; ++o) &#123; s = t = 0; memset(vis, false, sizeof vis); memset(dis, 0, sizeof dis); for(int p=1; p&lt;=n; ++p) &#123; int v = -1; for(int i=1; i&lt;=n; ++i) if(!flag[i] and !vis[i] and (v == -1 or dis[v] &lt; dis[i])) v = i; if(v == -1) break; vis[v] = true; s=t, t=v; for(int i=1; i&lt;=n; ++i) if(!flag[i] and !vis[i]) dis[i] += g[t][i]; &#125; flag[t] = true; ans = min(ans, dis[t]); if(ans == 0) break; for(int i=1; i&lt;=n; ++i) &#123; if(flag[i]) continue; g[s][i] += g[t][i]; g[i][s] += g[i][t]; &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"},{"name":"网络流","slug":"algorithm/network-flow","permalink":"https://snow.js.org/categories/algorithm/network-flow/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"网络流","slug":"网络流","permalink":"https://snow.js.org/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"最小割","slug":"最小割","permalink":"https://snow.js.org/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"}]},{"title":"CF387D","slug":"cf387d","date":"2020-04-24T16:00:00.000Z","updated":"2021-01-19T00:42:42.359Z","comments":true,"path":"cf387d/","link":"","permalink":"https://snow.js.org/cf387d/","excerpt":"","text":"# CF387D # 题意分析 操作最少的次数，构成有趣图，注意无重边，有向边。 操作分为加边和删边。 有趣图定义 有一个中心，满足此点有自环，且与其他结点有双向边。 除中心点外的结点，满足出度 = 入度 = 2。 # 算法分析 1、仔细分析有趣图的定义，发现如下性质： 中心的边数为 (n−1)×2+1(n-1)\\times 2+1(n−1)×2+1，也就是它与其他结点要有双向边再加自己的一个自环，无重边所以构造中心点时不可能做删除操作，只能加边或不操作。 其他结点的出入度为 2，排除掉与中心点连接的双向边，其点的度一定为一进一出。 2、如何判断结点的度满足一进一出。 图一，图二都是满足结点度一进一出。所以 nnn 个结点需要 nnn 条相连边（首尾）。 图三不满足，只有两条相连边 (e1,e2)(e_1,e_2)(e1​,e2​) 或者选择 (e1,e3)(e_1,e_3)(e1​,e3​) 即有用边，还需要添加 n−2n-2n−2 边有用边，同时还要减掉 1 条边，即总边数减去有用边，也就是要删除的无用边。 方法 1：拆点，一个点拆为进点和出点，建立二分图。 ​ 左边的点求匹配，最大匹配就是有用的边。 方法 2：直接将图看成二分图，利用有向边每个点都求匹配。 3、枚举每个点做中心点。 中心点 V，计算维护中心需要的边 (n−1)×2+1−∑(n-1)\\times 2+1-\\sum(n−1)×2+1−∑ 删除 V 点，也就是包含相应的边 剩下的图，计算最大匹配，满足一进一出的边数需要的操作（添加边 + 删除边）。 #include &lt;stdio.h>#include &lt;string.h>#include &lt;limits.h>#include &lt;vector>#include &lt;iostream>using namespace std;const int N = 550, INF = INT_MAX;vector&lt;int> g[N];int c, n, m;int tag = 0, vis[N], match[N];bool mp[N][N];bool dfs(int u) &#123; for(int i = 0; i &lt; g[u].size(); ++i) &#123; int v = g[u][i]; if(v == c) continue; if(vis[v] == tag) continue; vis[v] = tag; if(match[v] == 0 or dfs(match[v])) &#123; match[v] = u; return true; &#125; &#125; return false;&#125;int best = INF;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); int sum0 = 0; for(int i=1, u, v; i&lt;=m; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); g[u].push_back(v); mp[u][v] = true; ++sum0; &#125; for(int i=1; i&lt;=n; ++i) &#123; memset(match, 0, sizeof match); c = i; int ans = 0; int sum1 = 0; for(int j=1; j&lt;=n; ++j) &#123; if(j == c) &#123; if(mp[c][c]) ++sum1; continue; &#125; if(mp[j][c]) ++sum1; if(mp[c][j]) ++sum1; &#125; ans += 2*(n-1) + 1 - sum1; //printf(\"ans1 = %d\\n\", ans); //printf(\"sum1 = %d\\n\", sum1); int sum2 = 0; for(int j=1; j&lt;=n; ++j) &#123; ++tag; if(j == c) continue; if(dfs(j)) ++sum2; &#125; ans += sum0 - sum1 - sum2 + n-1 - sum2; best = min(best, ans); //printf(\"ans2 = %d\\n\", ans); //printf(\"sum2 = %d\\n\", sum2); &#125; printf(\"%d\\n\", best); return 0;&#125;","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"二分图","slug":"二分图","permalink":"https://snow.js.org/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"匹配","slug":"匹配","permalink":"https://snow.js.org/tags/%E5%8C%B9%E9%85%8D/"}]},{"title":"匹配：模板","slug":"匹配：模板","date":"2020-04-18T16:00:00.000Z","updated":"2021-01-19T00:42:42.086Z","comments":true,"path":"match-template/","link":"","permalink":"https://snow.js.org/match-template/","excerpt":"","text":"# 匹配：模板 # UOJ78 二分图最大匹配（DFS - KM） #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;const int N = 550;int match[N], g[N][N], vis[N], link[N];int n, m, e, tag, ans = 0;bool dfs(int u) &#123; for(int v=1; v&lt;=m; ++v) &#123; if(!g[u][v] or vis[v] == tag) continue; vis[v] = tag; if(!match[v] or dfs(match[v])) &#123; match[v] = u; return true; &#125; &#125; return false;&#125;int main() &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;e); for(int i=1, u, v; i&lt;=e; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); g[u][v] = true; &#125; for(int i=1; i&lt;=n; ++i) &#123; tag = i; if(dfs(i)) ++ans; &#125; printf(\"%d\\n\", ans); for(int i=1; i&lt;=m; ++i) link[match[i]] = i; for(int i=1; i&lt;=n; ++i) printf(\"%d \", link[i]); return 0;&#125;# UOJ79 一般图最大匹配（带花树） #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;queue>using namespace std;const int N = 550;int fa[N], match[N], pre[N], vis[N];int tag = 0, n, m, ans = 0;int flag[N];bool g[N][N];queue&lt;int> q;void clear(queue&lt;int> &amp;q) &#123; queue&lt;int> empty; swap(q, empty);&#125;int belong(int u) &#123; return fa[u] == u ? u : fa[u] = belong(fa[u]);&#125;void path(int u) &#123; while(u) &#123; int v = match[pre[u]]; match[u] = pre[u]; match[pre[u]] = u; u = v; &#125;&#125;int lca(int u, int v) &#123; ++tag; u = belong(u); v = belong(v); while(vis[u] != tag) &#123; vis[u] = tag; u = belong(pre[match[u]]); if(v) swap(u, v); &#125; return u;&#125;void connect(int u, int v, int root) &#123; while(belong(u) != root) &#123; pre[u] = v; v = match[u]; if(flag[v] == 2) &#123; q.push(v); flag[v] = 1; &#125; if(belong(u) == u) fa[u] = root; if(belong(v) == v) fa[v] = root; u = pre[v]; &#125;&#125;bool bfs(int u) &#123; memset(flag, 0, sizeof flag); memset(pre, 0, sizeof pre); for(int i=1; i&lt;=n; ++i) fa[i] = i; clear(q); q.push(u); flag[u] = 1; while(!q.empty()) &#123; u = q.front(); q.pop(); for(int v=1; v&lt;=n; ++v) &#123; if(!g[u][v]) continue; if(flag[v] == 0) &#123; pre[v] = u; if(match[v] == 0) &#123; path(v); return true; &#125; q.push(match[v]); flag[v] = 2; flag[match[v]] = 1; &#125; else &#123; if(flag[v] == 2) continue; if(belong(u) == belong(v)) continue; int root = lca(u, v); connect(u, v, root); connect(v, u, root); &#125; &#125; &#125; return false;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for(int i=1, u, v; i&lt;=m; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); g[u][v] = g[v][u] = true; &#125; for(int i=1; i&lt;=n; ++i) if(match[i] == 0 and bfs(i)) ++ans; printf(\"%d\\n\", ans); for(int i=1; i&lt;=n; ++i) printf(\"%d \", match[i]); return 0;&#125;# UOJ80 二分图最大权匹配（BFS - KM） #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;typedef long long LL;const int N = 440;const LL INF = 0x3f3f3f3f3f3f3f3f;bool vis[N];int pre[N], link[N], res[N];int n, m, e;LL g[N][N], lx[N], ly[N], d[N], ans = 0;void bfs(int k) &#123; int x, y = 0; LL min1 = INF, delta; memset(vis, false, sizeof vis); memset(pre, 0, sizeof pre); memset(d, 0x3f, sizeof d); link[y] = k; do &#123; x = link[y], delta = INF, vis[y] = true; for(int i=1; i&lt;=m; ++i) &#123; if(!vis[i]) &#123; if(d[i] > lx[x] + ly[i] - g[x][i]) &#123; d[i] = lx[x] + ly[i] - g[x][i]; pre[i] = y; &#125; if(delta > d[i]) delta = d[i], min1 = i; &#125; &#125; for(int i=0; i&lt;=m; ++i) if(vis[i]) lx[link[i]] -= delta, ly[i] += delta; else d[i] -= delta; y = min1; &#125; while(link[y]); while(y) link[y] = link[pre[y]], y = pre[y];&#125;int main() &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;e); m = max(n, m); for(int i=1; i&lt;=e; ++i) &#123; int u, v; LL w; scanf(\"%d%d%lld\", &amp;u, &amp;v, &amp;w); g[u][v] = w; lx[u] = max(lx[u], w); &#125; for(int i=1; i&lt;=n; ++i) bfs(i); for(int i=1; i&lt;=m; ++i) &#123; if(!g[link[i]][i]) continue; ans += g[link[i]][i]; res[link[i]] = i; &#125; printf(\"%lld\\n\", ans); for(int i=1; i&lt;=n; ++i) printf(\"%d \", res[i]); return 0;&#125;","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"二分图","slug":"二分图","permalink":"https://snow.js.org/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"匹配","slug":"匹配","permalink":"https://snow.js.org/tags/%E5%8C%B9%E9%85%8D/"}]},{"title":"沼","slug":"沼","date":"2020-04-04T16:00:00.000Z","updated":"2021-01-19T00:42:42.088Z","comments":true,"path":"numa/","link":"","permalink":"https://snow.js.org/numa/","excerpt":"","text":"p{text-indent: 32px;} # 沼 沼底的尽头，是一片覆压百万里的金色宫殿。大殿的外墙上，布满了交通错落的铭文，似是在昭示着什么。 一天，一个女孩闯入了这里。一阵和煦的金光顿时笼罩了她；俄而散去，四下无痕。 没过了几个小时，又进来了一个男孩，像是在呼唤着什么（或是呼唤着谁）。金光一如既往地扩散开来；一道道刻痕爆裂而开，流转着金黄的光珠，跳动着淡蓝的光焰 —— 但一切终又重归了平静。唯一不同的是男孩进入的那座殿堂，蒙上了雪一般的白色，白得灼痛了双眼 —— 殿中央，一个男孩旁边躺着一个女孩。在渐渐模糊的视野里，他们站起了身，向沼底的深处走去。突然地，一座一座的宫殿轰然倒下，杳然无踪，连瓦砾都浸没在夕阳里。 他们的面前是一片水原。 “没有再向前的路了呢，” 男孩道。 “那⋯⋯要不就在这里？” 女孩问道。 男孩没有回答。空无一物的海面上，反射着太阳的光辉。 “这里⋯⋯没有我能回去的地方了。” 女孩的心微微一颤。 黑云压了下来。男孩看向她的眼睛；那双湛蓝的天空里，像是有两束晶莹的泪在燃烧。 “你回去吧，” 男孩在岸边坐下。冰冷的寂静刺穿了黑暗。“你还有更重要的东西。” “—— 那你呢？” “我？…… 雨女无瓜。” 女孩再次担忧地看了他一眼，转过身去。五彩斑斓的黑洇染了苍穹，等男孩回过神来，已是孤身一人。 他向前迈了一步。一座巨浪打在他脚下，险些将他卷为齑粉。要是她还在这里的话，说不定已经被撕碎了呢，他想。 他轻轻咬了咬唇，刚挤出的笑容粉碎在脸上。他自知最多也就能到这里了，还是回去为好。 他拾起石子掷向水中；石子弹跳着沉了下去。 黑夜却还不急着到来。太阳迸发出血红的光芒，向西方吃力地转动着。 男孩在水底见到了他的朋友。一只巨大的鲲。 “还要在这里待多久？” 男孩试探着问道。 “多久？” 鲲摇了摇尾巴，“我不知道。” “…… 真的没打算离开嘛？” “离开？离开幹什么？” 鲲又摇了摇尾巴，脸上露出奇异的神色来。男孩平静地看向他。 “—— 没事了。” 男孩侧过头去，脸上始终没有浮现过可以称之为表情的东西。四下的水雾扩散开来，像狰狞的水母的触手一样，箍紧了沼底的天空。 自非亭午夜分，不见曦月。 女孩坐在大殿的中央，看着周遭的残壁在烈火中熔释。火光给她的脸染成了金色；凤凰在她的脑畔上盘旋，就像穿行在无边的旷野，有着挣脱一切的力量。 “如何？” 她问道。 “还好吧，” 他没有抬头，“就是还得再适应一点时间。需要重铸的事情太多了。” “或许吧，” 她附和道。 她的目光望向窗外：雪花从天中飘落，给葱茏的树叶抹上了一层白霜。 “抱歉了。” 男孩点了点头。 她的瞳孔一缩。若是重开一次，她想，这些话本不应该被说出来的。她会不会…… 男孩和他都在等待着什么。她定定地望向他。 四面的风静了下来。 女孩回到了水原 ——or she expected so。一团团死掉的水嘶叫着从湖底的罅隙里鱼贯而出，取而代之的，是一条条岩浆的河；大地像饼干一样脆生生地从中间裂开，散落出无数如粉如沙的碎片，点缀在覆压百万里的橘红的海洋中，就像一口沸腾的锅，把晚霞也煮成了一般颜色。 她回过头：来时的路早已淹没在了递归的沼泽里。 女孩迟疑了一下，随即向着东方走去。月亮追赶着太阳，终于将它逼到了地平线下。 她一次也没有回头。","categories":[{"name":"小说 & 随笔","slug":"hitokoto","permalink":"https://snow.js.org/categories/hitokoto/"},{"name":"未来","slug":"hitokoto/future","permalink":"https://snow.js.org/categories/hitokoto/future/"}],"tags":[{"name":"小说","slug":"小说","permalink":"https://snow.js.org/tags/%E5%B0%8F%E8%AF%B4/"}]},{"title":"网络流：模板","slug":"网络流：模板","date":"2020-04-04T16:00:00.000Z","updated":"2021-01-19T00:42:42.357Z","comments":true,"path":"network-flow-template/","link":"","permalink":"https://snow.js.org/network-flow-template/","excerpt":"","text":"# 网络流：模板 # P3376 网络最大流（Dinic） #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;queue>using namespace std;const int N = 11000, M = 110000;const int INF = 0x7fffffff;struct node &#123; int u, v, w, next;&#125; e[M &lt;&lt; 1];int cur[N], h[N], tot;int dfn[N], ans, n, m, s, t;void add(int u, int v, int w) &#123; e[tot] = node(&#123;u, v, w, h[u]&#125;); cur[u] = h[u] = tot++;&#125;bool bfs() &#123; memset(dfn, 0, sizeof dfn); queue&lt;int> q; dfn[s] = 1; q.push(s); while(!q.empty()) &#123; int u = q.front(); q.pop(); for(int i = h[u]; i != -1; i = e[i].next) &#123; int v = e[i].v; if(e[i].w and !dfn[v]) &#123; dfn[v] = dfn[u] + 1; q.push(v); if(v == t) return true; &#125; &#125; &#125; return false;&#125;int dfs(int u, int low) &#123; if(u == t) return low; int w = low; for(int i = cur[u]; i != -1; i = e[i].next) &#123; int v = e[i].v; cur[u] = i; if(e[i].w and dfn[v] == dfn[u] + 1) &#123; int f = dfs(v, min(w, e[i].w)); e[i].w -= f; e[i^1].w += f; w -= f; if(!w) break; &#125; &#125; return low - w;&#125;void dinic() &#123; while(bfs()) &#123; memcpy(cur, h, sizeof cur); ans += dfs(s, INF); &#125;&#125;int main() &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;s, &amp;t); memset(h, -1, sizeof h); for(int i=1, u, v, w; i&lt;=m; ++i) &#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, 0); &#125; dinic(); printf(\"%d\\n\", ans); return 0;&#125;# P3381 最小费用最大流（单路增广） # Dijkstra #include &lt;stdio.h>#include &lt;string.h>#include &lt;queue>using namespace std;#define il inlineconst int N = 5500, M = 55000, INF = 0x3f3f3f3f;struct point &#123; int u, val; point(int _u = 0, int _val = 0): u(_u), val(_val) &#123;&#125; bool operator &lt; (const point &amp;o) const &#123; return val > o.val; &#125; &#125;;priority_queue &lt;point> q;struct node &#123; int u, v, w, f, next; node() &#123;&#125;&#125; e[M &lt;&lt; 1];int head[N], tot = 0;il void add(int u, int v, int w, int f) &#123; e[tot].u = u, e[tot].v = v, e[tot].w = w, e[tot].f = f; e[tot].next = head[u]; head[u] = tot++;&#125;int h[N], dis[N], flow[N], pre[N];int n, m, s, t;int maxflow = 0, mincost = 0;il bool dijkstra() &#123; memset(dis, 0x3f, sizeof dis); memset(flow, 0x3f, sizeof flow); memset(pre, -1, sizeof pre); dis[s] = 0; q.push(point(s, 0)); while (!q.empty()) &#123; int u = q.top().u, val = q.top().val; q.pop(); if (val > dis[u]) continue; for (int i = head[u]; i != -1; i = e[i].next) &#123; int v = e[i].v; if (e[i].w and dis[v] > dis[u] + e[i].f + h[u] - h[v]) &#123; pre[v] = i; flow[v] = min(flow[u], e[i].w); dis[v] = dis[u] + e[i].f + h[u] - h[v]; q.push(point(v, dis[v])); &#125; &#125; &#125; return dis[t] != INF;&#125;il void check() &#123; for (int p = pre[t]; p != -1; p = pre[e[p].u]) &#123; e[p].w -= flow[t]; e[p^1].w += flow[t]; &#125; maxflow += flow[t]; mincost += (dis[t] - h[s] + h[t]) * flow[t]; for(int i=1; i&lt;=n; ++i) h[i] += dis[i];&#125;int main() &#123; memset(head, -1, sizeof head); scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;s, &amp;t); for(int i=1, u, v, w, f; i&lt;=m; ++i) &#123; scanf(\"%d%d%d%d\", &amp;u, &amp;v, &amp;w, &amp;f); add(u, v, w, f); add(v, u, 0, -f); &#125; while (dijkstra()) check(); printf(\"%d %d\\n\", maxflow, mincost); return 0;&#125;# SPFA #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;queue>using namespace std;const int N = 5500, M = 110000, INF = 0x3f3f3f3f;struct node &#123; int u, v, w, f, next;&#125; e[M];int h[N], tot = 0;void add(int u, int v, int w, int f) &#123; e[tot] = &#123;u, v, w, f, h[u]&#125;; h[u] = tot++;&#125;int pre[N], flow[N], dis[N];bool vis[N];int n, m, s, t, maxflow, mincost;bool spfa() &#123; memset(pre, -1, sizeof pre); memset(vis, false, sizeof vis); memset(dis, 0x3f, sizeof dis); memset(flow, 0x3f, sizeof flow); queue&lt;int> q; q.push(s); vis[s] = true; dis[s] = 0; while(!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for(int i = h[u]; i != -1; i = e[i].next) &#123; int v = e[i].v; if(e[i].w and dis[v] > dis[u] + e[i].f) &#123; dis[v] = dis[u] + e[i].f; pre[v] = i; flow[v] = min(flow[u], e[i].w); if(!vis[v]) &#123; q.push(v); vis[v] = true; &#125; &#125; &#125; &#125; return dis[t] != INF;&#125;void check() &#123; for(int p = pre[t]; p != -1; p = pre[e[p].u]) &#123; e[p].w -= flow[t]; e[p^1].w += flow[t]; &#125; mincost += dis[t] * flow[t]; maxflow += flow[t];&#125;int main() &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;s, &amp;t); memset(h, -1, sizeof h); for(int i=1, u, v, w, f; i&lt;=m; ++i) &#123; scanf(\"%d%d%d%d\", &amp;u, &amp;v, &amp;w, &amp;f); add(u, v, w, f); add(v, u, 0, -f); &#125; while(spfa()) check(); printf(\"%d %d\\n\", maxflow, mincost); return 0;&#125;# LOJ115 无源汇有上下界可行流（超级源汇） #include &lt;stdio.h>#include &lt;string.h>#include &lt;queue>using namespace std;#define il inlineconst int N = 220, M = 11000, INF = 0x3f3f3f3f;struct node &#123; int u, v, w, next;&#125; e[M * 6];int head[N], cur[N], tot = 0;il void add(int u, int v, int w) &#123; e[tot] = (node) &#123;u, v, w, head[u]&#125;; head[u] = tot++;&#125;int h[N], n, m, ss, tt;il bool bfs() &#123; // 分层 memset(h, 0, sizeof h); memcpy(cur, head, sizeof cur); queue&lt;int> q; q.push(ss); h[ss] = 1; while(!q.empty()) &#123; int u = q.front(); q.pop(); for(int i = head[u]; i != -1; i = e[i].next) &#123; int v = e[i].v; if(e[i].w and !h[v]) &#123; h[v] = h[u] + 1; if(v == tt) return true; q.push(v); &#125; &#125; &#125; return false;&#125;int dfs(int u, int low) &#123; if(u == tt) return low; int w = low; for(int i = cur[u]; i != -1; i = e[i].next, cur[u] = i) &#123; int v = e[i].v; if(e[i].w and h[v] == h[u] + 1) &#123; int f = dfs(v, min(w, e[i].w)); e[i].w -= f; e[i^1].w += f; w -= f; if(!w) break; &#125; &#125; return low - w;&#125;int tflow = 0, sflow = 0;il void dinic() &#123; for(int i = head[ss]; i != -1; i = e[i].next) sflow += e[i].w; // 出流量 while(bfs()) dfs(ss, INF); for(int i = head[tt]; i != -1; i = e[i].next) tflow += e[i].w; // 入流量 if(sflow == tflow) &#123; // 满流 printf(\"YES\\n\"); for(int i=0; i&lt;tot; i+=6) printf(\"%d\\n\", e[i+1].w + e[i+5].w); // 反边流量和 &#125; else printf(\"NO\\n\"); &#125;int main() &#123; freopen(\"loj115.in\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;m); memset(head, -1, sizeof head); ss = 0, tt = n+1; for(int i=1, u, v, l, h; i&lt;=m; ++i) &#123; // 建图 scanf(\"%d%d%d%d\", &amp;u, &amp;v, &amp;l, &amp;h); add(u, tt, l); add(tt, u, 0); add(ss, v, l); add(v, ss, 0); add(u, v, h-l); add(v, u, 0); &#125; dinic(); return 0;&#125;# 有源汇有上下界（转无源汇，然后断边） # 最大流（顺流增广） #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;queue>using namespace std;const int N = 220, M = 22000, INF = 0x3f3f3f3f;struct node &#123; int u, v, w, next;&#125; e[M];int head[N], cur[N], tot = 0;void add(int u, int v, int w) &#123; e[tot] = (node) &#123;u, v, w, head[u]&#125;; head[u] = tot++; e[tot] = (node) &#123;v, u, 0, head[v]&#125;; head[v] = tot++;&#125;int h[N], in[N], n, m, s, t, ss, tt, sflow = 0, tflow = 0;bool bfs(int s, int t) &#123; memset(h, 0, sizeof h); memcpy(cur, head, sizeof cur); queue&lt;int> q; q.push(s); h[s] = 1; while(!q.empty()) &#123; int u = q.front(); q.pop(); for(int i = head[u], v; i != -1; i = e[i].next) &#123; v = e[i].v; if(e[i].w and !h[v]) &#123; h[v] = h[u] + 1; if(v == t) return true; q.push(v); &#125; &#125; &#125; return false;&#125;int dfs(int u, int low, int t) &#123; if(u == t) return low; int w = low; for(int i = cur[u], v; i != -1; i = e[i].next, cur[u] = i) &#123; v = e[i].v; if(e[i].w and h[v] == h[u] + 1) &#123; int f = dfs(v, min(w, e[i].w), t); e[i].w -= f; e[i^1].w += f; w -= f; if(!w) break; &#125; &#125; return low - w;&#125;int main() &#123; //freopen(\"loj116.in\", \"r\", stdin); scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;s, &amp;t); ss = 0, tt = n+1; memset(head, -1, sizeof head); for(int i=1, u, v, l, h; i&lt;=m; ++i) &#123; scanf(\"%d%d%d%d\", &amp;u, &amp;v, &amp;l, &amp;h); in[u] -= l; in[v] += l; add(u, v, h-l); &#125; for(int i=1; i&lt;=n; ++i) &#123; if(!in[i]); else if(in[i] > 0) &#123; sflow += in[i]; add(ss, i, in[i]); &#125; else &#123; add(i, tt, -in[i]); &#125; &#125; add(t, s, INF); while(bfs(ss, tt)) tflow += dfs(ss, INF, tt); if(sflow != tflow) &#123; printf(\"please go home to sleep\\n\"); return 0; &#125; for(int i = head[ss]; i != -1; i = e[i].next) e[i].w = e[i^1].w = 0; for(int i = head[tt]; i != -1; i = e[i].next) e[i].w = e[i^1].w = 0; int sum = e[--tot].w; e[tot-1].w = e[tot].w = 0; while(bfs(s, t)) sum += dfs(s, INF, t); printf(\"%d\\n\", sum); return 0;&#125;# 最小流（逆流增广） #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;queue>using namespace std;const int N = 220, M = 22000, INF = 0x3f3f3f3f;struct node &#123; int u, v, w, next;&#125; e[M];int head[N], cur[N], tot = 0;void add(int u, int v, int w) &#123; e[tot] = (node) &#123;u, v, w, head[u]&#125;; head[u] = tot++; e[tot] = (node) &#123;v, u, 0, head[v]&#125;; head[v] = tot++;&#125;int h[N], in[N], n, m, s, t, ss, tt, sflow = 0, tflow = 0;bool bfs(int s, int t) &#123; memset(h, 0, sizeof h); memcpy(cur, head, sizeof cur); queue&lt;int> q; q.push(s); h[s] = 1; while(!q.empty()) &#123; int u = q.front(); q.pop(); for(int i = head[u], v; i != -1; i = e[i].next) &#123; v = e[i].v; if(e[i].w and !h[v]) &#123; h[v] = h[u] + 1; if(v == t) return true; q.push(v); &#125; &#125; &#125; return false;&#125;int dfs(int u, int low, int t) &#123; if(u == t) return low; int w = low; for(int i = cur[u], v; i != -1; i = e[i].next, cur[u] = i) &#123; v = e[i].v; if(e[i].w and h[v] == h[u] + 1) &#123; int f = dfs(v, min(w, e[i].w), t); e[i].w -= f; e[i^1].w += f; w -= f; if(!w) break; &#125; &#125; return low - w;&#125;int main() &#123; //freopen(\"loj116.in\", \"r\", stdin); scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;s, &amp;t); ss = 0, tt = n+1; memset(head, -1, sizeof head); for(int i=1, u, v, l, h; i&lt;=m; ++i) &#123; scanf(\"%d%d%d%d\", &amp;u, &amp;v, &amp;l, &amp;h); in[u] -= l; in[v] += l; add(u, v, h-l); &#125; for(int i=1; i&lt;=n; ++i) &#123; if(!in[i]); else if(in[i] > 0) &#123; sflow += in[i]; add(ss, i, in[i]); &#125; else &#123; add(i, tt, -in[i]); &#125; &#125; add(t, s, INF); while(bfs(ss, tt)) tflow += dfs(ss, INF, tt); if(sflow != tflow) &#123; printf(\"please go home to sleep\\n\"); return 0; &#125; for(int i = head[ss]; i != -1; i = e[i].next) e[i].w = e[i^1].w = 0; for(int i = head[tt]; i != -1; i = e[i].next) e[i].w = e[i^1].w = 0; int sum = e[--tot].w; e[tot-1].w = e[tot].w = 0; while(bfs(s, t)) sum += dfs(s, INF, t); printf(\"%d\\n\", sum); return 0;&#125;","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"},{"name":"网络流","slug":"algorithm/network-flow","permalink":"https://snow.js.org/categories/algorithm/network-flow/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"最短路","slug":"最短路","permalink":"https://snow.js.org/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"网络流","slug":"网络流","permalink":"https://snow.js.org/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"网络流：Dijkstra 求费用流","slug":"网络流：Dijkstra-求费用流","date":"2020-02-28T16:00:00.000Z","updated":"2021-01-19T00:42:42.357Z","comments":true,"path":"network-flow-dijkstra/","link":"","permalink":"https://snow.js.org/network-flow-dijkstra/","excerpt":"","text":"# 网络流：Dijkstra 求费用流 注：下文中的边权 www 均表示费用 fff。 Dijkstra 不能求有负权边的最短路，所以我们可以对网络 GGG 中的每一个点设置一个势函数 h(u)h(u)h(u)，以满足在与原图等价的新图中的边权非负。 # 最短路 在任意残留网络中的任意边 (u,v)(u,v)(u,v) 都需要满足： wu,v+h(u)−h(v)≥0w_{u, v}+h(u) - h(v)≥0 wu,v​+h(u)−h(v)≥0 令图 GGG 的等价图为 G′G&#x27;G′，其对应的边 (u,v)(u,v)(u,v) 的权值为 wu,v′=wu,v+h(u)−h(v)w&#x27;_{u,v} = w_{u,v} + h(u) - h(v) wu,v′​=wu,v​+h(u)−h(v) 因此，对于原图中的任意一条路径 (u1,u2,…,uk)(u_1,u_2,\\dots,u_k)(u1​,u2​,…,uk​)，它在 GGG 中的权值为 wu1,u2+wu2,u3+⋯+wuk−1,ukw_{u_1,u_2}+w_{u_2,u_3}+\\dots+w_{u_{k-1},u_k} wu1​,u2​​+wu2​,u3​​+⋯+wuk−1​,uk​​ 在 G′G&#x27;G′ 中的权值可化简为 wu1,u2+wu2,u3+⋯+wuk−1,uk+h(u1)−h(uk)w_{u_1,u_2} + w_{u_2,u_3} + \\dots + w_{u_{k-1}, u_k} + h(u_1)-h(u_k) wu1​,u2​​+wu2​,u3​​+⋯+wuk−1​,uk​​+h(u1​)−h(uk​) 所以，在 G′G&#x27;G′ 求出的路径都可以对应到 GGG 上。 令 dud_{u}du​ 为图 GGG 中源点 sss 到点 uuu 的最短路径，图 G′G&#x27;G′ 中为 du′d&#x27;_{u}du′​，显然有 du,v=du,v′−h(u)+h(v)d_{u,v} = d&#x27;_{u,v}-h(u)+h(v) du,v​=du,v′​−h(u)+h(v) 所以我们只需要求 G′G&#x27;G′ 的最短路径，就能对应回原图的最短路径。 # 势函数 # 初值 如果网络 GGG 初始边权非负，则令 h(u)=0h(u)=0h(u)=0 ，否则可令 h(u)=dis[u]h(u) = dis[u]h(u)=dis[u]（用 SPFA 解决）。 证明略。 # 维护 每次增广后，令 h(u)=h(u)+dis[u]h(u)=h(u)+dis[u]h(u)=h(u)+dis[u] 即可。 证明：对于残余网络上的任意边 (u,v)(u,v)(u,v)，均有 dis[u]+wu,v+h(u)−h(v)≥dis[v]dis[u]+w_{u,v}+h(u)-h(v)≥dis[v] dis[u]+wu,v​+h(u)−h(v)≥dis[v] 移项，得 wu,v+(h(u)+dis[u])−(h(v)+dis[v])≥0w_{u,v}+(h(u)+dis[u])-(h(v)+dis[v]) \\geq 0 wu,v​+(h(u)+dis[u])−(h(v)+dis[v])≥0 证毕。 # P3381 ［模板］最小费用最大流 #include &lt;stdio.h>#include &lt;string.h>#include &lt;queue>using namespace std;#define il inlineconst int N = 5500, M = 55000, INF = 0x3f3f3f3f;struct point &#123; int u, val; point(int _u = 0, int _val = 0): u(_u), val(_val) &#123;&#125; bool operator &lt; (const point &amp;o) const &#123; return val > o.val; &#125; &#125;;priority_queue &lt;point> q;struct node &#123; int u, v, w, f, next; node() &#123;&#125;&#125; e[M &lt;&lt; 1];int head[N], tot = 0;il void add(int u, int v, int w, int f) &#123; e[tot].u = u, e[tot].v = v, e[tot].w = w, e[tot].f = f; e[tot].next = head[u]; head[u] = tot++;&#125;int h[N], dis[N], flow[N], pre[N];int n, m, s, t;int maxflow = 0, mincost = 0;il bool dijkstra() &#123; memset(dis, 0x3f, sizeof dis); memset(flow, 0x3f, sizeof flow); memset(pre, -1, sizeof pre); dis[s] = 0; q.push(point(s, 0)); while (!q.empty()) &#123; int u = q.top().u, val = q.top().val; q.pop(); if (val > dis[u]) continue; for (int i = head[u]; i != -1; i = e[i].next) &#123; int v = e[i].v; if (e[i].w and dis[v] > dis[u] + e[i].f + h[u] - h[v]) &#123; pre[v] = i; flow[v] = min(flow[u], e[i].w); dis[v] = dis[u] + e[i].f + h[u] - h[v]; q.push(point(v, dis[v])); &#125; &#125; &#125; return dis[t] != INF;&#125;il void check() &#123; for (int p = pre[t]; p != -1; p = pre[e[p].u]) &#123; e[p].w -= flow[t]; e[p^1].w += flow[t]; &#125; maxflow += flow[t]; mincost += (dis[t] - h[s] + h[t]) * flow[t]; for(int i=1; i&lt;=n; ++i) h[i] += dis[i];&#125;int main() &#123; freopen(\"p3381.in\", \"r\", stdin); memset(head, -1, sizeof head); scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;s, &amp;t); for(int i=1, u, v, w, f; i&lt;=m; ++i) &#123; scanf(\"%d%d%d%d\", &amp;u, &amp;v, &amp;w, &amp;f); add(u, v, w, f); add(v, u, 0, -f); &#125; while (dijkstra()) check(); printf(\"%d %d\\n\", maxflow, mincost); return 0;&#125;","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"},{"name":"网络流","slug":"algorithm/network-flow","permalink":"https://snow.js.org/categories/algorithm/network-flow/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"最短路","slug":"最短路","permalink":"https://snow.js.org/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"网络流","slug":"网络流","permalink":"https://snow.js.org/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"网络流：消圈算法","slug":"网络流：消圈算法","date":"2020-02-28T16:00:00.000Z","updated":"2021-01-19T00:42:42.358Z","comments":true,"path":"network-flow-deloop/","link":"","permalink":"https://snow.js.org/network-flow-deloop/","excerpt":"","text":"# 网络流：消圈算法 注：下文中的权均表示费用。 # 消圈定理 在某个流 fff 中，如果其残余网络中没有负圈（剩余流量为 000 的边视为不存在），那它一定是当前流量下的最小费用，否则一定不是。 # 证明 假设一个网络，所有边的容量都是 111。 如果流量走上路的话，其残余网络（黑箭头）变为： 因为上路的边的流量占满了，所以现在上路只有反边。 显然 A→C→t→B→AA \\rightarrow C \\rightarrow t \\rightarrow B \\rightarrow AA→C→t→B→A 为负圈，沿此负圈增广（每条边的流量＋1），环上每个点的入流量仍然等于出流量（原流为可行流）。 流量在圈中增广，总的流量既没有增加，也没有减少，只不过是流量从费用更少的地方流过 （A→C→tA \\rightarrow C \\rightarrow tA→C→t），从费用大的地方退流而已（t→B→At \\rightarrow B \\rightarrow At→B→A），流过的流量和退掉的流量是相等的，实质上只是将从 AAA 流出的流量的方向改变，使得费用更小。 网络流的反边给了我们一个很好的反悔机制，使得我们可以对任意一个流 fff，通过消负圈（可能不止一个），来得到它当前流量下的最小费用流。 可以看到，沿着负圈增广之后，已经没有负圈存在了，已经达到了当前流量下的最小费用流（也就是最小费用最大流）。所以只要有负圈，就可以增广达到更小费用。 # 应用 求最小费用最大流时，可以先跑出一条可行最大流，然后通过不断消圈调整出最小费用。 更广泛用于残余网络寻找更优解。 # POJ2175 Evacuation Plan # 题面 原题面很长。 给出已达到最大流的残余网络，求出其是否已达到最小费用，如果未达到则找出更优方案。 # 思路 消圈模板，建出网络后利用 SPFA，如果一个节点被更新了 nnn 次则说明图中一定存在负环。题目中没有说必须是最优解，因此只要将负圈上的流量调整 111 即可。 注意一个节点被更新 nnn 次不代表其一定在负权圈内。正确做法是从这个节点 vvv 开始不断捯它的前驱，如果发现某个节点 uuu 被访问了两遍，则说明 uuu 一定在负权圈内，再根据 uuu 去捯前驱调整负权圈。 # 图解 好像有几个地方标错了 QAQ 凑合看吧 # 代码 #include &lt;stdio.h>#include &lt;string.h>#include &lt;queue>using namespace std;#define il inlinetemplate &lt;typename T> il T abs(T x) &#123; return x > 0 ? x : -x; &#125;const int N = 110, M = N * N &lt;&lt; 1, INF = 0x3f3f3f3f;struct coor &#123; int x, y, z;&#125; a[N], b[N];struct node &#123; int u, v, w, f, next;&#125; e[M];int h[N &lt;&lt; 1], tot = 0;bool vis[N &lt;&lt; 1];int n, m, s, t;int cnt[N &lt;&lt; 1], pre[N &lt;&lt; 1];il void add(int u, int v, int w, int f) &#123; e[tot] = (node) &#123;u, v, w, f, h[u]&#125;; h[u] = tot++;&#125;int bp[N][N], dis[N &lt;&lt; 1], p[N][N], occ[N];deque&lt;int> q;bool cyc[N &lt;&lt; 1];il void check(int v) &#123; do &#123; cyc[v] = true; v = e[pre[v]].u; &#125; while(!cyc[v]); int u = v; do &#123; --e[pre[v]].w; ++e[pre[v]^1].w; v = e[pre[v]].u; &#125; while(u != v); for(int i=1; i&lt;=m; ++i) for(int j = h[n+i]; j != -1; j = e[j].next) if(e[j].v != t) bp[e[j].v][i] = e[j].w; printf(\"SUBOPTIMAL\\n\"); for(int i=1; i&lt;=n; ++i) &#123; for(int j=1; j&lt;=m; ++j) printf(\"%d \", bp[i][j]); printf(\"\\n\"); &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for(int i=1; i&lt;=n; ++i) scanf(\"%d%d%d\", &amp;a[i].x, &amp;a[i].y, &amp;a[i].z); for(int i=1; i&lt;=m; ++i) scanf(\"%d%d%d\", &amp;b[i].x, &amp;b[i].y, &amp;b[i].z); for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=m; ++j) scanf(\"%d\", &amp;p[i][j]), occ[j] += p[i][j]; memset(h, -1, sizeof h); s = 0, t = n+m+1; for(int i=1; i&lt;=n; ++i) &#123; add(s, i, a[i].z, 0); add(i, s, 0, 0); &#125; for(int i=1; i&lt;=n; ++i) &#123; for(int j=1; j&lt;=m; ++j) &#123; int f = abs(a[i].x - b[j].x) + abs(a[i].y - b[j].y) + 1; add(i, n+j, INF, f); add(n+j, i, p[i][j], -f); &#125; &#125; for(int i=1; i&lt;=m; ++i) &#123; add(n+i, t, b[i].z - occ[i], 0); add(t, n+i, occ[i], 0); &#125; memset(dis, 0x3f, sizeof dis); q.push_front(s); vis[s] = true; ++cnt[s]; dis[s] = 0; while(!q.empty()) &#123; int u = q.front(); q.pop_front(); vis[u] = false; for(int i = h[u]; i != -1; i = e[i].next) &#123; int v = e[i].v; if(e[i].w and dis[v] > dis[u] + e[i].f) &#123; pre[v] = i; dis[v] = dis[u] + e[i].f; if(!vis[v]) &#123; if(!q.empty() and dis[v] >= dis[q.front()]) q.push_back(v); else q.push_front(v); vis[v] = true; ++cnt[v]; if(cnt[v] == t+1) &#123; check(v); return 0; &#125; &#125; &#125; &#125; &#125; printf(\"OPTIMAL\\n\"); return 0;&#125;算法证明中的图片引自 Sengxian’s Blog。","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"},{"name":"网络流","slug":"algorithm/network-flow","permalink":"https://snow.js.org/categories/algorithm/network-flow/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"最短路","slug":"最短路","permalink":"https://snow.js.org/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"网络流","slug":"网络流","permalink":"https://snow.js.org/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]},{"title":"陌上","slug":"陌上","date":"2020-02-04T16:00:00.000Z","updated":"2021-01-19T00:42:42.358Z","comments":true,"path":"mo-shang/","link":"","permalink":"https://snow.js.org/mo-shang/","excerpt":"","text":"# 陌上 default 多少次咫尺之隔的希望 却终是目送着的离开 最美好的时候（） ？ 多少次经意又不经意 自然而又矫情 踌躇在触手可及的门口 隔的是无限的冰凌 缓慢而痛彻心扉 冷漠而撕心裂肺 就算你冷若冰霜 就算残存的桥被时间的流冲淡 就算寒冰封冻了每一处角落 水雾浸湿了他的眼 留下往生不灭的洇痕 我 命不由天 就算悸动的心被死寂的水销毁 就算迟来的阳光等不到花开的日子 就算此时相望不相闻 溱与洧 方涣涣兮 明天 愿往来翕忽的鱼儿 离开涸辙的田野 愿熙熙攘攘的行人 离开郁孤台的障翳 愿逐月华 流照君 纵使过往的种种想要钦定了未来 纵使层迭的细沙似已磨灭了你我 （不甘、仗剑、人） 斩的 就是命运 纵使真的到达了最黑暗的时刻 纵使远方的洪流咆哮着向着未来 纵使湛蓝的天空里爱恨交盏 纵使 山无棱 如果再相遇 我想 陪你一起 飞过彷徨 看最初的一道光 凤凰于飞 覆照殷红 夕阳","categories":[{"name":"小说 & 随笔","slug":"hitokoto","permalink":"https://snow.js.org/categories/hitokoto/"},{"name":"陌上","slug":"hitokoto/陌上","permalink":"https://snow.js.org/categories/hitokoto/%E9%99%8C%E4%B8%8A/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://snow.js.org/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"尺取法","slug":"尺取法","date":"2020-02-03T16:00:00.000Z","updated":"2021-01-19T00:42:42.358Z","comments":true,"path":"ruler-method/","link":"","permalink":"https://snow.js.org/ruler-method/","excerpt":"","text":"# 尺取法 与单调队列相关 要求在满足条件的情况下，长度越长，答案越好（下简称具有单调性）. 利用双指针 l,rl,rl,r 及队列思想，对于同一个 lll 让 rrr 尽可能延伸至最远，得到一个答案区间，rrr 已到达最远后将与 lll 有关的信息弹出，对于多个答案区间找出最优解． # HDU5178 Pairs # 题面 有 nnn 个值 x1,x2,…,xnx_1, x_2, \\dots,x_nx1​,x2​,…,xn​，求使得 ∣xb−xa∣⩽k,a&lt;b|x_b-x_a|\\leqslant k,a&lt;b∣xb​−xa​∣⩽k,a&lt;b 的数对 (a,b)(a,b)(a,b) 的个数． # 解 分析可知 a&lt;ba&lt;ba&lt;b 这一条件只是确保无重复，次序其实对于最终答案没有影响． 考虑先对 xxx 排序（因原题目有绝对值，无影响），for​ lll 尺取出最远的 rrr， 则 (l,r](l,r](l,r] 间的每个数均与 lll 构成合法数对． # 代码 #include &lt;stdio.h>#include &lt;algorithm>const int N = 110000;typedef long long LL;int T, n;LL k, x[N];int main() &#123; freopen(\"hdu5178.in\", \"r\", stdin); scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d%lld\", &amp;n, &amp;k); for(int i=1; i&lt;=n; ++i) scanf(\"%lld\", x+i); std::sort(x+1, x+n+1); LL ans = 0; for(int l=1, r=2; l&lt;=n; ++l) &#123; for(; r &lt;= n and x[r] - x[l] &lt;= k; ++r); ans += r - l - 1; &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125;# HDU6119 小小粉丝度度熊 类似 CF1041D Glider # 题面 给出 nnn 个已签到的天数区间，mmm 张补签卡，求可获得的最大连续签到时长。 # 解 尺取模板。 天数区间可重叠，须进行合并。 需要注意的是，当已确定最长合法区间 [l,r][l,r][l,r] 后（即下一个区间与 rrr 的距离大于剩余的补签卡数量，连不上），应把剩余补签卡全部应用到 rrr 之后的天数上得到更优解。 # 代码 边界条件较多。 RRR 为已加入队列的最后一个区间，判断的是区间 R+1R+1R+1 的合法性。 特判第一个区间，开始时 sumsumsum 直接加上第一个已签到区间的长，使用 000 张补签卡。 #include &lt;stdio.h>#include &lt;algorithm>using namespace std;const int N = 110000;struct node &#123; int l, r;&#125; a[N], b[N];bool flag[N];bool cmp(node a, node b) &#123; return a.l &lt; b.l; &#125;int n, m;int max(int a, int b) &#123; return a > b ? a : b; &#125;int main() &#123; freopen(\"hdu6119.in\", \"r\", stdin); while(scanf(\"%d%d\", &amp;n, &amp;m) != EOF) &#123; for(int i=1; i&lt;=n; ++i) scanf(\"%d%d\", &amp;b[i].l, &amp;b[i].r), flag[i] = false; sort(b+1, b+n+1, cmp); for(int i=2; i&lt;=n; ++i) &#123; if(b[i-1].r >= b[i].l) &#123; b[i].l = b[i-1].l; b[i].r = max(b[i].r, b[i-1].r); flag[i-1] = true; &#125; &#125; int tot = 0; for(int i=1; i&lt;=n; ++i) &#123; if(flag[i]) continue; a[++tot].l = b[i].l; a[tot].r = b[i].r; &#125; int sum = a[1].r - a[1].l + 1, f = 0, ans = 0; for(int L = 1, R = 1; L &lt;= tot; ++L) &#123; for(; R + 1 &lt;= tot and f + a[R+1].l - a[R].r - 1 &lt;= m; ++R) sum += a[R+1].r - a[R].r, f += a[R+1].l - a[R].r - 1; ans = max(ans, sum + m - f); sum -= a[L+1].l - a[L].l; f -= a[L+1].l - a[L].r - 1; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;# HDU1937 Finding Seats # 题面 电影院有 RRR 行 CCC 列，用 '.' 表示空座， 'X' 表示不可选。 要求选择至少 KKK 个空座位 (xi,yi)(x_i, y_i)(xi​,yi​)，使得 (max⁡xi−min⁡xi)⋅(max⁡yi−min⁡yi),1⩽i⩽K(\\max x_i -\\min x_i)\\cdot(\\max y_i -\\min y_i),1\\leqslant i \\leqslant K (maxxi​−minxi​)⋅(maxyi​−minyi​),1⩽i⩽K 最小。 # 解 二维尺取。 枚举题目所求长方形的上下界，尺取求出左右最短距离。用二维前缀和简化空位查找。 # 代码 #include &lt;stdio.h>#include &lt;iostream>using namespace std;const int N = 330;int row, c, k;char str[N];int s[N][N];int query(int x1, int y1, int x2, int y2) &#123; return s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];&#125;int main() &#123; freopen(\"hdu1937.in\", \"r\", stdin); while(true) &#123; scanf(\"%d%d%d\", &amp;row, &amp;c, &amp;k); if(row == 0 and c == 0 and k == 0) break; for(int i=1; i&lt;=row; ++i) &#123; scanf(\"%s\", str+1); int sum = 0; for(int j=1; j&lt;=c; ++j) &#123; sum += (str[j] == '.' ? 1 : 0); s[i][j] = s[i-1][j] + sum; &#125; &#125; int ans = 0x7fffffff; for(int up = 1; up &lt;= row; ++up) &#123; for(int down = up; down &lt;= row; ++down) &#123; for(int l=1, r=1; l&lt;=c; ++l) &#123; for(; r&lt;=c; ++r) &#123; if(query(up, l, down, r) >= k) &#123; ans = min(ans, (down - up + 1) * (r - l + 1)); break; &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;# HDU5358 First One # 题面 有一数列 a1,a2,…,ana_1, a_2, \\dots, a_na1​,a2​,…,an​，求 ∑i=1n∑j=in(i+j)(⌊log⁡2∑k=ijak⌋+1)\\sum_{i=1}^{n} \\sum_{j=i}^{n} (i + j)(\\lfloor \\log_2 \\sum_{k=i}^{j} a_k \\rfloor + 1) i=1∑n​j=i∑n​(i+j)(⌊log2​k=i∑j​ak​⌋+1) 的值。特别地，log⁡20=0\\log_20=0log2​0=0。 # 解 观察上式，对于 ⌊log⁡⌋\\lfloor\\log\\rfloor⌊log⌋ 来说，它的一个值可对应很多个真数，考虑分块。 枚举 ⌊log⁡2∑k=ijak⌋\\lfloor \\log_2 \\sum_{k=i}^{j} a_k \\rfloor⌊log2​∑k=ij​ak​⌋ 的每一个值（1~34）。 令 v=⌊log⁡2∑k=ijak⌋v =\\lfloor \\log_2 \\sum_{k=i}^{j} a_k \\rfloor v=⌊log2​k=i∑j​ak​⌋ sum=∑k=ijaksum = \\sum_{k=i}^{j}a_k sum=k=i∑j​ak​ 则 sum∈[2v−1,2v)sum \\in [2^{v-1},2^v) sum∈[2v−1,2v) 用尺取求出部分和在此范围的区段 [i,j][i,j][i,j]，求出结果加入计数器。 # 代码 #include &lt;stdio.h>#include &lt;iostream>using namespace std;const int N = 110000;typedef long long LL;LL cl[40], a[N], s[N];int T, n;int main() &#123; freopen(\"hdu5358.in\", \"r\", stdin); cl[0] = -1, cl[1] = 1; for(int i=2; i&lt;=34; ++i) cl[i] = ((cl[i-1] + 1) &lt;&lt; 1LL) - 1; scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d\", &amp;n); for(int i=1; i&lt;=n; ++i) scanf(\"%lld\", a+i); for(int i=1; i&lt;=n; ++i) s[i] = s[i-1] + a[i]; LL ans = 0; for(LL k=1; k&lt;=34; ++k) &#123; LL l = 0, r = 0; for(LL i=1; i&lt;=n; ++i) &#123; for(l = max(l, i); l &lt;= n and s[l] - s[i-1] &lt;= cl[k-1]; ++l); for(r = max(l, r); r &lt;= n and s[r] - s[i-1] &lt;= cl[k]; ++r); ans += k * (i * (r-l) + (l+r-1) * (r-l) / 2); &#125; &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125;# HDU6103 Kirinriki # 题面 有两字符串 A,BA,BA,B（从 111 编号），长度均为 nnn，定义 dis(A,B)=∑i=1n∣Ai−Bn−i∣dis(A,B) = \\sum_{i=1}^n|A_i-B_{n-i}| dis(A,B)=i=1∑n​∣Ai​−Bn−i​∣ 字符之差定义为其 ASCII 码的差。 对于一字符串 SSS，找出它的两个不重叠连续子串，他们的 disdisdis 不大于 mmm，求最长合法子串长度。 # 解 寻找单调性，易得 ∀S′⊆S,T′⊆T:dis(S′,T′)⩽dis(S,T)\\forall S&#x27; \\subseteq S,T&#x27;\\subseteq T:dis(S&#x27;,T&#x27;)\\leqslant dis(S,T) ∀S′⊆S,T′⊆T:dis(S′,T′)⩽dis(S,T) 因此子串越长越好。 又∵\\because∵ ∀\\forall∀ 两个合法子串，其必关于母串的某一位置（或某两位置之间）对称，考虑枚举这一中心点，分上面的两种情况。 注意到对于每个子串，其长度越大越好，同时又有约束上界，可对称尺取。 # 代码 #include &lt;stdio.h>#include &lt;string.h>int abs(int x) &#123; return x > 0 ? x : -x; &#125;int max(int a, int b) &#123; return a > b ? a : b;&#125;int T, n, m;char s[22000];int main() &#123; freopen(\"hdu6103.in\", \"r\", stdin); scanf(\"%d\", &amp;T); while(T--) &#123; scanf(\"%d\", &amp;m); scanf(\"%s\", s+1); int n = strlen(s+1), ans = 0; for(int i=1; i&lt;=n; ++i) &#123; int f = 0; for(int l1 = i-1, r1 = i-1, l2 = i+1, r2 = i+1; l1 > 0 and l2 &lt;= n; --l1, ++l2) &#123; for(; r1 > 0 and r2 &lt;= n and f + abs(s[r1] - s[r2]) &lt;= m; --r1, ++r2) f += abs(s[r1] - s[r2]); ans = max(ans, r2 - l2); f -= abs(s[l1] - s[l2]); &#125; &#125; for(int i=1; i&lt;=n; ++i) &#123; int f = 0; for(int l1 = i, r1 = i, l2 = i+1, r2 = i+1; l1 > 0 and l2 &lt;= n; --l1, ++l2) &#123; for(; r1 > 0 and r2 &lt;= n and f + abs(s[r1] - s[r2]) &lt;= m; --r1, ++r2) f += abs(s[r1] - s[r2]); ans = max(ans, r2 - l2); f -= abs(s[l1] - s[l2]); &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;# POJ2739 Sum of Consecutive Prime Numbers 尺取水题。 #include &lt;stdio.h>#include &lt;cmath>using namespace std;bool prime(int x) &#123; if(x &lt; 2) return false; int m = int(sqrt(x)); for(int i=2; i&lt;=m; ++i) if(x % i == 0) return false; return true;&#125;int x, p[11000];int main() &#123; int tot = 0; for(int i=1; i&lt;=10000; ++i) &#123; if(prime(i)) p[++tot] = i; &#125; while(true) &#123; scanf(\"%d\", &amp;x); if(x == 0) break; int f = 0, ans = 0; for(int l=1, r=1; l&lt;=tot; ++l) &#123; for(; r &lt;= tot and f + p[r] &lt;= x; ++r) f += p[r]; if(f == x) ++ans; f -= p[l]; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;# CF1198A MP3 # 题面 给出 n,In,In,I。 nnn - 数列 a1,a2,...,ana_1,a_2,...,a_na1​,a2​,...,an​ 选定一个区间 [l,r][l,r][l,r]，并进行操作，使 vi={lvi&lt;lvil⩽vi⩽rrvi&gt;rv_i = \\begin{cases} l&amp;v_i&lt;l\\\\ v_i&amp;l\\leqslant v_i \\leqslant r\\\\ r&amp;v_i&gt;r \\end{cases} vi​=⎩⎪⎪⎨⎪⎪⎧​lvi​r​vi​&lt;ll⩽vi​⩽rvi​&gt;r​ 要求经过处理后，数列中不同的数的个数 ⩽2⌊8I/n⌋\\leqslant 2^{\\lfloor 8I/n\\rfloor}⩽2⌊8I/n⌋，且使数列中被更改的位置的总数最小，求这个最小值。 # 解 原题面较长，需耐心看题。 可先将原数列排序并离散化，记下每种数的出现次数，用前缀和优化求和。因顺序已预先排好，直接尺取 [l,r][l,r][l,r]，使区间内的值最大化，用总数相减得出答案。 # 代码 #include &lt;cstdio>#include &lt;cmath>#include &lt;algorithm>using namespace std;const int N = 440000; int a[N], b[N], cnt[N], s[N], n, I, t; int power(int x) &#123; int ans = 1, base = 2; for(; x; x >>= 1) &#123; if(x &amp; 1) ans *= base; if(ans > t) return ans; base *= base; &#125; return ans;&#125; int main() &#123; freopen(\"cf1198a.in\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;I); for(int i=1; i&lt;=n; ++i) scanf(\"%d\", a+i), b[i] = a[i]; if(8*I > n*((int)log2(n) + 1)) &#123; printf(\"0\\n\"); return 0; &#125; sort(b+1, b+n+1); t = unique(b+1, b+n+1) - (b+1); int K = power(8*I/n); for(int i=1; i&lt;=n; ++i) &#123; int p = lower_bound(b+1, b+t+1, a[i]) - b; ++cnt[p]; &#125; for(int i=1; i&lt;=t; ++i) s[i] = s[i-1] + cnt[i]; int ans = 0x7fffffff; for(int l=1, r; l&lt;=t; ++l) &#123; r = min(l + K - 1, t); ans = min(ans, s[t] - (s[r] - s[l-1])); &#125; printf(\"%d\\n\", ans); return 0;&#125;# CF180E Cubes # 题意简述 现有一数列 a1,a2,…,an(1⩽ai⩽m)a_1,a_2,…,a_n (1\\leqslant a_i \\leqslant m)a1​,a2​,…,an​(1⩽ai​⩽m)（更准确地翻译的话，现有一排小方块，第 iii 个方块的颜色为 aia_iai​），求在最多删去 kkk 个位置的数后，所能获得的最长连续子段的长度，要求该子段中所有数均相同． # 解释 可以不删数． 1⩽n⩽2×1051 \\leqslant n \\leqslant 2 \\times 10^51⩽n⩽2×105，1⩽m⩽1051 \\leqslant m \\leqslant 10^51⩽m⩽105，0⩽k&lt;n0 \\leqslant k &lt;n0⩽k&lt;n． 样例 #1：删去 5th5th5th 和 6th6th6th． 样例 #2：删去 4th4th4th 和 7th7th7th． 样例 #3：不变． # 解答 枚举每种颜色，这样问题就可被简化为对于每种颜色，求出其修改后的最长合法子段，可用尺取法求解。 尺取法与单调队列有关，应用范围比较小，要求原问题在满足条件的情况下，长度越长，答案越好。利用双指针 l,rl,rl,r 及队列思想，对于同一个 lll 让 rrr 尽可能延伸至最远，得到一个答案区间，rrr 已到达最远后将与 lll 有关的信息弹出，对于多个答案区间找出最优解。 更详细的解释请看这里 # 代码 将原数列分块，对每种颜色建立链表，枚举时直接访问。 链表的每个节点存储该颜色块的左右端点。 #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>using namespace std;const int N = 220000, M = 110000;struct node &#123; int l, r, next;&#125; a[N];int tmp[M], n, m, k, h[M];int main() &#123; freopen(\"cf180e.in\", \"r\", stdin); scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); int f = 0, tot = 0, ans = 0; for(int i=1, c; i&lt;=n; ++i) &#123; scanf(\"%d\", &amp;c); if(f == c) a[tot].r = i; else &#123; a[++tot] = (node) &#123;i, i, c, 0&#125;; if(h[x]) a[tmp[c]].next = tmp[c] = tot; else h[x] = tmp[x] = tot; f = c; &#125; &#125; for(int i=1; i&lt;=m; ++i) &#123; if(h[i] == 0) continue; // 无该颜色 int L = h[i], R = h[i], f = 0, sum = a[h[i]].r - a[h[i]].l + 1; for(; L; L = a[L].next) &#123; for(; a[R].next and f + a[a[R].next].l - a[R].r - 1 &lt;= k; R = a[R].next) f += a[a[R].next].l - a[R].r - 1, sum += a[a[R].next].r - a[a[R].next].l + 1; ans = max(ans, sum); // 统计 sum -= a[L].r - a[L].l + 1; // 弹出 f -= a[a[L].next].l - a[L].r - 1; &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125;# CF939E Maximize! # 题面 对于一个只包含正整数的 multiset SSS，你需要支持以下 222 种操作： 111 找出 SSS 的一个子集 sss，使 max(s)−mean(s)max(s)-mean(s)max(s)−mean(s) 最大，并输出这个最大值。保留十位小数。 222 xxx 加入一个新数 xxx 到 SSS 中，保证加入的数是递增的。 # 解 思维题。 maxmaxmax 越大越好，meanmeanmean 越小越好。 结论一：子集 sss 中必包含 max⁡S\\max SmaxS。 结论二：∀x∈S,x∉s,mean(s)&gt;x:mean(s)&lt;mean(s∪{x})\\forall x \\in S, x\\notin s,mean(s) &gt; x:mean(s) &lt; mean(s\\cup\\{x\\})∀x∈S,x∈/s,mean(s)&gt;x:mean(s)&lt;mean(s∪{x})​ 。 证明略。 # 代码 略丑。 为防止 WA，特判了较小的情况，维护的也略微麻烦一点。 #include &lt;stdio.h>const int N = 550000;typedef double LF;int Q, s[N];int main() &#123; freopen(\"cf939e.in\", \"r\", stdin); int tot = 0, f = 0; LF sum = 0, lastans = 0, lasttype = 0; scanf(\"%d\", &amp;Q); while(Q--) &#123; int type; scanf(\"%d\", &amp;type); if(type == 1) &#123; scanf(\"%d\", &amp;s[++tot]); lasttype = type; &#125; else &#123; if(lasttype == 2) &#123; printf(\"%.10lf\\n\", lastans); continue; &#125; if(tot == 1) &#123; printf(\"%.10lf\\n\", (LF)0); lastans = 0; lasttype = 2; continue; &#125; if(tot == 2) &#123; lastans = s[2] - (s[1] + s[2]) / 2.0; printf(\"%.10lf\\n\", lastans); lasttype = 2; sum = s[1], f = 1; continue; &#125; for(int i=f+1; i&lt;tot; ++i) &#123; if((LF)(sum + s[tot]) / i > (LF)s[i]) f = i, sum += s[i]; else break; &#125; lastans = s[tot] - (sum + s[tot]) / (f+1); printf(\"%.10lf\\n\", lastans); lasttype = type; &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"单调队列","slug":"单调队列","permalink":"https://snow.js.org/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"尺取法","slug":"尺取法","permalink":"https://snow.js.org/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"},{"name":"双指针","slug":"双指针","permalink":"https://snow.js.org/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"单调队列","slug":"单调队列","date":"2020-01-31T16:00:00.000Z","updated":"2021-01-19T00:42:42.086Z","comments":true,"path":"monotonous-queue/","link":"","permalink":"https://snow.js.org/monotonous-queue/","excerpt":"","text":"# 单调队列 具有单调性的队列。当一新值准备入队时，须先从后向前，将对后来答案没有了影响的点弹出，再从前向后，将所有超出了统计范围的点弹出。对于大多数问题，求解过程中会锁定很多答案区间，在线求最值。 # P3088 拥挤的奶牛 # 题面 有 NNN 头奶牛沿着一维的栅栏吃草，第 iii 头奶牛在目标点 xix_ixi​，它的身高是 hih_ihi​ 。当一头奶牛左边 DDD 距离内而且右边 DDD 距离内有身高至少是它的两倍的奶牛，它就会觉得拥挤。 请计算觉得拥挤的奶牛的数量。 # 解 （单调队列模板？） 当一奶牛将要入队时： 从后往前，将身高小于该奶牛的弹出（ --tail ），因为将要进队的奶牛更加靠后，影响范围一定更大，对答案的贡献也一定更大。 从前往后，将与该奶牛距离已超过 DDD 的奶牛弹出（ ++head ） 将该奶牛入队。 与队头奶牛比较身高，若符合则打上标记，若左右两次统计均符合，则计入答案。 每次统计的是该奶牛左侧的合法性，从后到前再做一遍就可以了。 按照以上规则就可以统计答案了。显然该队列一定为单调递降队列。 # 代码 #include &lt;stdio.h>#include &lt;algorithm>using namespace std;const int N = 55000;struct node &#123; int x, h;&#125; a[N];int n, d, queue[N];bool l[N], r[N];bool cmp(node a, node b) &#123; return a.x &lt; b.x;&#125;int main() &#123; freopen(\"p3088.in\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;d); for(int i=1; i&lt;=n; ++i) scanf(\"%d%d\", &amp;a[i].x, &amp;a[i].h); sort(a+1, a+n+1, cmp); int head = 0, tail = 1; queue[head] = 1; for(int i=2; i&lt;=n; ++i) &#123; while(head &lt; tail and a[queue[tail-1]].h &lt;= a[i].h) --tail; queue[tail++] = i; while(head &lt; tail and a[i].x - a[queue[head]].x > d) ++head; if(a[queue[head]].h >= (a[i].h &lt;&lt; 1)) l[i] = true; &#125; head = 0, tail = 1; queue[head] = n; for(int i=n-1; i>=1; --i) &#123; while(head &lt; tail and a[queue[tail-1]].h &lt;= a[i].h) --tail; queue[tail++] = i; while(head &lt; tail and a[queue[head]].x - a[i].x > d) ++head; if(a[queue[head]].h >= (a[i].h &lt;&lt; 1)) r[i] = true; &#125; int ans = 0; for(int i=1; i&lt;=n; ++i) if(l[i] and r[i]) ++ans; printf(\"%d\\n\", ans); return 0;&#125;# P3522 Temperature # 题面 有 nnn 个段，第 iii 个为 [li,ri][l_i, r_i][li​,ri​]，现要在几个连续的段中，每段中各取一个值，构成一序列，要求该序列不能下降，求序列的最大长度。 # 解 以段的左端点维护单调序列。 当一新段将要入队时： 从后向前，将所有左点比新段的左点小的段弹出。 从前向后，将所有右点比新段的左点小的段弹出。 统计答案：用当前位置减去队头的上一段的位置 ∵\\because∵ 队头的上一段已被弹出 ∴\\therefore∴ 从队头的上一段的下一段起（可能已被弹出）至当前位置均属于合法序列 # 代码 #include &lt;stdio.h>const int N = 1100000;int max(int a, int b) &#123; return a > b ? a : b; &#125;int n, l[N], r[N], queue[N], ans = -1;int main() &#123; freopen(\"p3522.in\", \"r\", stdin); scanf(\"%d\", &amp;n); for(int i=1; i&lt;=n; ++i) scanf(\"%d%d\", l+i, r+i); int head = 0, tail = 1; queue[head] = 0; for(int i=1; i&lt;=n; ++i) &#123; while(head &lt; tail and l[i] >= l[queue[tail-1]]) --tail; queue[tail++] = i; while(head &lt; tail and l[queue[head]] > r[i]) ++head; ans = max(ans, i - queue[head-1]); &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"单调队列","slug":"单调队列","permalink":"https://snow.js.org/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"}]},{"title":"About CODESTYLE","slug":"CODESTYLE","date":"2020-01-20T16:00:00.000Z","updated":"2021-01-19T00:42:42.359Z","comments":true,"path":"about-codestyle/","link":"","permalink":"https://snow.js.org/about-codestyle/","excerpt":"","text":"# commit 命名规范 feat: 一个新功能 fix: 一个 bug 修复 docs: 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE 等 style: 不影响代码逻辑的修改，比如空格、格式缩进、删除分号等 refactor: 代码重构 perf: 提升性能的改动 test: 增加或修改测试 chore: 改变构建流程、或者增加辅助工具、依赖库等 # 2020.04.05 修改： 2020.02 中的所有修改作废。 # 2020.02 修改： 最近喜欢用 inline 。 尽量避免强制类型转换。 使用构造函数。 # 2020.01 修改： 凡继承自 C 语言的库，均使用 &lt;xxx.h&gt; 而不是 &lt;cxxx&gt; 。 以下情况中，运算符前后一定不加空格： for 循环括号内内容较短时（e.g. for(int i=1; i&lt;=n; ++i) ） 运算符前后关系较密切时 以下情况中，运算符前后一般不加空格： 变量名长度为 1 时 以下情况中，运算符前后可能不加空格： 考试即将结束时 以下情况中，运算符前后不可能不加空格： 除以上情况之外的所有情况 typedef long long LL 。 # e.g. （ 2-SAT 模板节选） #include &lt;stdio.h>#include &lt;string.h>#include &lt;iostream>#include &lt;stack>using namespace std;const int N = 2e6 + 10;struct node &#123; int u, v, next; node() &#123;&#125; node(int _u, int _v, int _next): u(_u), v(_v), next(_next) &#123;&#125;&#125; e[N];int h[N], tot = 0;void add(int u, int v) &#123; e[++tot] = node(u, v, h[u]); h[u] = tot;&#125;int dfn[N], low[N], tag = 0;int id[N], num = 0;stack&lt;int> s;int n, m;void tarjan(int u) &#123; dfn[u] = low[u] = ++tag; s.push(u); for(int i = h[u]; i; i = e[i].next) &#123; int v = e[i].v; if(dfn[v]) &#123; if(!id[v]) low[u] = min(low[u], dfn[v]); &#125; else &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; &#125; if(dfn[u] == low[u]) &#123; id[u] = ++num; for(; s.top() != u; s.pop()) id[s.top()] = num; s.pop(); &#125;&#125;int main() &#123; freopen(\"p4782.in\", \"r\", stdin); scanf(\"%d%d\", &amp;n, &amp;m); for(int i=1, _i, a, _j, b, u, v; i&lt;=m; ++i) &#123; scanf(\"%d%d%d%d\", &amp;_i, &amp;a, &amp;_j, &amp;b); u = (_i-1)*2 + a, v = (_j-1)*2 + b; add(u^1, v); add(v^1, u); &#125; for(int i=0; i&lt;(n&lt;&lt;1); ++i) if(!dfn[i]) tarjan(i); for(int i=0; i&lt;(n&lt;&lt;1); i+=2) &#123; if(id[i] == id[i^1]) &#123; printf(\"IMPOSSIBLE\\n\"); return 0; &#125; &#125; printf(\"POSSIBLE\\n\"); for(int i=0; i&lt;(n&lt;&lt;1); i+=2) printf(\"%d \", id[i] &lt; id[i^1] ? 0 : 1); return 0;&#125;# 考场码风： （牛客 CSP-S 提高组赛前集训营 2 T3 - 维护序列 2019.10.31 ） #include &lt;cstdio> const int N = 100005, INF = 0x7fffffff;int abs(int x) &#123; return x > 0 ? x : -x; &#125;int min(int a, int b) &#123; return a > b ? b : a; &#125; struct node &#123; int a, b, f, s; node *l, *r;&#125; *root, pool[4*N]; struct pair &#123; int l, r;&#125; tmpx[N], tmpy[N]; int id = -1, cntx, cnty;int s[N];node *newnode(int a, int b) &#123; pool[++id] = (node) &#123;a, b, s[a], 0, NULL, NULL&#125;; return &amp;pool[id];&#125; void build(node *&amp;root, int a, int b) &#123; root = newnode(a,b); if(a&lt;b) &#123; int mid = (a+b) >> 1; build(root->l, a, mid); build(root->r, mid+1, b); if(root->l->f == root->r->f) root->f = root->l->f; else root->f = 0; &#125;&#125; bool check(node *root, int x) &#123; if(root->f) return (root->f == x); bool s1 = check(root->l, x); bool s2 = check(root->r, x); return (s1 or s2); &#125; void edit(node *root, int a, int b, int x) &#123; if(a &lt;= root->a and root->b &lt;= b) &#123; root->f = x; return; &#125; if(root->f) &#123; root->l->f = root->f; root->r->f = root->f; root->f = 0; &#125; int mid = (root->a + root->b) >> 1; if(a &lt;= mid) edit(root->l, a, b, x); if(mid &lt; b) edit(root->r, a, b, x);&#125;bool query(node *root, int x, int y) &#123; if(root->f) &#123; if(root->f == x) tmpx[++cntx] = (pair) &#123;root->a, root->b&#125;; else if(root->f == y) tmpy[++cnty] = (pair) &#123;root->a, root->b&#125;; else return false; return true; &#125; bool s1 = query(root->l, x, y); bool s2 = query(root->r, x, y); return (s1 or s2);&#125; inline int read() &#123; char c = getchar(); int x=0, f=1; while(c &lt; '0' or c > '9') &#123; f = (c == '-') ? -1 : f; c = getchar(); &#125; while(c >='0' and c &lt;='9') &#123; x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c-'0'); c = getchar(); &#125; return x*f;&#125; int lastans = 0;int main() &#123; int n = read(), m = read(), flag = read(); for(int i=1; i&lt;=n; ++i) s[i] = read(); build(root, 1, n); for(int ii=1; ii&lt;=m; ++ii) &#123; if(!flag) lastans = 0; int opt = read(); if(opt == 1) &#123; int l = read()^lastans, r = read()^lastans, x = read()^lastans; edit(root, l, r, x); &#125; if(opt == 2) &#123; int x = read()^lastans, y = read()^lastans; if(x == y) &#123; bool f = check(root, x); lastans = 0; printf(\"%d\\n\", f ? 0 : -1); continue; &#125; cntx = cnty = 0; bool f = query(root, x, y); if(!f or !cntx or !cnty) &#123; printf(\"-1\\n\"); lastans = 0; continue; &#125; lastans = INF; for(int i=1; i&lt;=cntx; ++i) &#123; for(int j=1; j&lt;=cnty; ++j) &#123; lastans = min(lastans, abs(tmpx[i].r - tmpy[j].l)); lastans = min(lastans, abs(tmpx[i].l - tmpy[j].r)); &#125; &#125; printf(\"%d\\n\", lastans); &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"码风","slug":"码风","permalink":"https://snow.js.org/tags/%E7%A0%81%E9%A3%8E/"}]},{"title":"雪（精选集）","slug":"雪","date":"2019-12-31T16:00:00.000Z","updated":"2021-01-19T00:42:42.086Z","comments":true,"path":"snow/","link":"","permalink":"https://snow.js.org/snow/","excerpt":"","text":"# 一 星，梦，昙 时空的网交错在一起，织成了天上的星。 # 二 未来 我的视线依然投在远方。看着看着，我渐渐不明白有多少东西可以称得上是变化了。世界本来就没有形状。 # 三 沼 黑夜却还不急着到来。太阳迸发出血红的光芒，向西方吃力地转动着。 # 四 涉江 她可能还没有想到过那样的一天，雪花浸满了每一个角落。空自，她守望着梦乡。 # 五 凝眉 时不时地，他们凑在对方的耳边，轻声低语；欢谑声里，沉沉的烟火灿烂着，像雪染成的白绫。","categories":[{"name":"小说 & 随笔","slug":"hitokoto","permalink":"https://snow.js.org/categories/hitokoto/"}],"tags":[{"name":"小说","slug":"小说","permalink":"https://snow.js.org/tags/%E5%B0%8F%E8%AF%B4/"}]},{"title":"Terminal · 番外","slug":"Terminal · 番外","date":"2019-11-15T16:00:00.000Z","updated":"2021-01-19T00:42:42.087Z","comments":true,"path":"terminal-extra/","link":"","permalink":"https://snow.js.org/terminal-extra/","excerpt":"","text":"# Terminal・番外 他站在一片未知的天空里；他听到人的呐喊。 他看见了一群人，如同星星点点的火光，向着远处的一扇门去。 他看见了她。 他感受着她的面颊：寒气如冰锥一般刺了进来。他睁开眼。 她睁开眼。 他的心不禁悲凉起来了。 她嫣然一笑，胜过所有盛开的花。 她一次也没有回头。 向她刮来；从她的耳际掠过。 海边。他在海边伫立着。 一阵风儿吹过。在他的眼前一闪。 他终于叩了一下。 他试着喊了一声；无可弥补的梦。 他向前探了探；一道雷池；。 在他的眼前一闪；。 他迟疑了一下。两下？。 她加快了脚步。 他哪里来的勇气？ 她可还记得他？ (EOF) 2019.11.16 CSP-S 2019 D1 心态爆炸（80/300） AFO //zsh ak ioi WJH / LYZ 颓","categories":[{"name":"小说 & 随笔","slug":"hitokoto","permalink":"https://snow.js.org/categories/hitokoto/"},{"name":"陌上","slug":"hitokoto/陌上","permalink":"https://snow.js.org/categories/hitokoto/%E9%99%8C%E4%B8%8A/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://snow.js.org/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"浅谈 Splay（一）","slug":"浅谈 Splay","date":"2019-07-26T16:00:00.000Z","updated":"2021-01-19T00:42:42.356Z","comments":true,"path":"about-splay/","link":"","permalink":"https://snow.js.org/about-splay/","excerpt":"","text":"# 一、旋转（Zig - Zag） # 1. 右旋（Right Rotation） 观察每个节点的变化，其中每个节点都有指向其父节点的指针没有画出。 ①②③处节点连接有变化。 # （1）QQQ 的左子树修改为 PPP 的右子树的内容 即 BBB 成为 QQQ 的左子树， BBB 的父节点是 QQQ 。 q->left = p->right; p->right->father = q;注意 P​ 可能没有右子树（即不存在 P-&gt;right 节点）。 修改如下： q->left = p->right; if(p->right != NULL) p->right->father = q;# （2）PPP 的右子树修改为 QQQ ，且同时 QQQ 的父节点修改为 PPP 。 p->right = q; q->father = p;注意 Q 和 P 的左右子树有变化，所以 Q,P 的信息需要重新维护。 update(q); update(p); // 先 Q 后 P# （3）RRR 的子树应该修改为 PPP 需要判断 QQQ 是 RRR 的哪种子树，左子树则 PPP 给 RRR 的左子树，否则给右子树。 全局变量 rootrootroot 记录树根。 特判 QQQ 有可能就是树根（即 RRR 不存在）； if(r == NULL) &#123; p->father = NULL; root = p; return; &#125; if(q == r->left) &#123; r->left = p; p->father = r; &#125; else &#123; r->right = p; p->father = r; &#125;整理一下，不管 Q​ 有无父节点，P 的父节点均修改为 Q 的父节点。 p->father = r; // 记录树根 if(r == NULL) &#123; root = p; return; &#125; // 判断 P 连到 R 的那颗子树 if(q == r->left) r->left = p; else r->right = p;Code : void right_rotate(node *p) &#123; node *q = p->father; // 记录 p 的父节点 node *r = q->father; // 记录 p 的父节点的父节点 // 操作 1 q->left = p->right; if(p->right != NULL) p->right->father = q; // 操作 2 p->right = q; q->father = p; // 维护节点信息（注意此处可暂不维护 P） update(q); //update(p); // 操作 3 p->father = r; if(r == NULL) &#123; root = p; return; &#125; if(q == r->left) r->left = p; else r->right = p; &#125;# 2、左旋（Left Rotation） 同理右旋，只是①②不同。 Code : void left_rotate(node *p) &#123; node *q = p->father; // 记录 p 的父节点 node *r = q->father; // 记录 p 的父节点的父节点 // 操作 1 q->right = p->left; if(p->left != NULL) p->left->father = q; // 操作 2 p->left = q; q->father = p; // 维护节点信息 update(q); //update(p); // 操作 3 p->father = r; if(r == NULL)&#123; root = p; return; &#125; if(q == r->left) r->left = p; else r->right = p; &#125;# 3、双旋 不断旋转 XXX 节点，为了保证复杂度，需要连续旋转两次且旋转的次序不同。 定义 XXX 的父节点为 YYY，YYY 的父节点为 ZZZ。 # （1）XXX 和 YYY 同时是其父节点的左子树或者同时是各自父节点的右子树（即同侧）。 这时我们要进行两次旋转，先旋转 YYY，再旋转 XXX。 同左旋转演示图如下： 同右旋转演示图如下： # （2）XXX 和 YYY 是其父节点的左、右子树，不同侧（即一左一右或一右一左）。 这时我们只要 旋转两次 X​ 即可。 # （3）判断 XXX 节点如何旋转。 XXX 是其父节点的左子树则右旋，否则左旋。 XXX 若是它父节点左子树返回 true ，否则返回 false ： bool getlr(node *p) &#123; return (p->father->left == p);&#125; // 选择合适的旋转方式void rotate(node *p) &#123; if(getlr(p)) right_rotate(p); else left_rotate(p);&#125;# 二、旋转到根 将 XXX 旋转到根是 splay 的关键，为了保证复杂度，只要对 XXX 节点操作，操作后就要将其旋转到根。 如何旋转到根： 一步旋转就可以到根，进行单旋； 两步或两步以上，可以不断使用双旋。 设计函数 splay(p,q) 将 PPP 旋转到 QQQ 下方。 q == NULL 表示 PPP 旋转到了根； while PPP 至少两次旋转才能到达：双旋； if PPP 还差一步满足条件：单旋。 Code : void splay(node *p, node *tar) &#123; while(p->father != tar and p->father->father != tar) &#123; if(getlr(p) == getlr(p->father)) &#123; rotate(p->father); rotate(p); &#125; else &#123; rotate(p); rotate(p); &#125; &#125; if(p->father != tar) rotate(p); update(p); // 优化（避免重复维护）&#125;","categories":[{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://snow.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"平衡树","slug":"平衡树","permalink":"https://snow.js.org/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"}]},{"title":"未来","slug":"未来","date":"2019-02-11T16:00:00.000Z","updated":"2021-01-19T00:42:42.356Z","comments":true,"path":"future/","link":"","permalink":"https://snow.js.org/future/","excerpt":"","text":"p{text-indent: 32px;} 未来 “When you have that last piece of the jigsaw, everything will, I hope, be clear. . . .&quot; 「引子」 我听着《我们仍不知道那年中美合拍的日子》，突然，章老师走了进来。我打开空气净化器，看了看垃圾桶里闪闪发光的律师函。 总之，故事就这样开始了。 「初雪」 六老师签售会当天，现场热闹的很。 “六爷爷…… 孙悟空到底有几个女朋友啊？” “所以我经常说，” 章承恩回头望了望摄像机。“戏说不是胡说，改编不是乱编。…… 一个民族…… 文化…… 谢罪…… 拿着棒子这么走……” 这时，“啊 ——” 的一声惨叫传来。六水线旁，一名男子倒在地上，已经没有了气息。 —— “死者名叫戴杉并，29 岁，在金猴皮鞋厂工作，不过似乎并不是他的主业。在他的电脑里，我们找到了很多线索表明这位海军上将……” 三谷（Mitani）汇报道。 “行了行了，” 我不耐烦地打断道，“我名侦探江户川（Edogawa）可不是来听你 × × 的。说吧，名单上还有谁？” “你怎么知道……” 三谷失声道。 “喂喂，” 我敲了敲桌子，“就你这智商还想干这事？告诉你吧，作者看你蠢成这样，特意派我来带你走向人生巅峰的。所以，现在 ——” 「正宫」 那天，我听闻杨洁导演去世了，准备好挽联，前去吊唁。 灵堂的气氛非常肃穆。那边六老师竟也换上了一袭黑衣，毕恭毕敬地垂下头，低声道： “今年下半年…… 中美合拍…… 杨洁导演满意…… 多多支持。” 我沉痛地走出灵堂，外面的天已经黑了。天上的几颗星星闪着明灭的冷光。 我低头看了看手表：十三时二十六分。 难道是……？！ 我缓而又缓地回过头。气势恢宏的大堂已经了无踪影。一望无际的原野上，章老师和几个吊唁的人似乎也意识到了什么，震悚地踅向四周。 突然，一道白痕闪了光，现了一个人，急匆匆地跑了过来。我看到他那惊愕之下掩着的笑意的脸，不禁一声哀叹： “唉！又是这个蠢货！” 就在这时，高速跑动的他像是被什么绊了一下，“咚” 地一声趴在了地上。 额…… 我不得不承认的是，虽然作者的确缺乏才华（很多时候都要靠我自己的演技），但在关键问题的处理上却是一点也不含糊。 我一边想着，一边向人群走去。 「Q&A」 只听得章老师对着全国人民破口大骂道： “等我回去以后，一个一个给你们寄律师函…… 对了，今年下半年……” Question：人类的本质是什么？ Wrong Answer：复读机 Accepted：人类的本质是什么？ 「设计实验」 （好像又扯远了…… 说正事） “必须灭杜！” 桌对面的一个人大声喊道。我回过神来。 我皱起眉。那个名叫马三傻（Ma Wasabi）的人又来了。 旁边的那个人似乎也毫无兴致，一脸心不在焉地附和着。 “…… 灭杜使我成为一个完整的人。？” “…… 啊？对对对，一点也不能剩。” 上原（Uehara）答道。 “咦，怎么不见时川（Tokikawa）来？” 我向邻座的新见（Shimmi）问道。他摇摇头。 “不知道。许是睡过头了吧。” 话虽这么说，但一个小时后，时川还没有下来。我因闲得无聊，便打开「神奇动物园」。这是一款专为睿智人群设计的高端手游，画面精良，很适合用来打发时间。 “时川还不下来？” 工藤（Kudo）不耐烦道。 “要不上去看一下吧，” 我提议道。 我同工藤到得他的房间口，敲了敲门。没有应声。 “等我给他打个电话。” 工藤拿出寻呼机。电话铃响到第十三下时，他摇头。“没有人接。” 我们没有办法，只好找来了服务人员。我推开门：这里并没有人。 “他的背包还在，应该是没准备长时间外出的。” 工藤道。 我点点头。看来也不会有什么发现了。“走吧，” 我说道。 工藤和我正要离开之时，我的目光落在了浴室的门框上。门的合页上，圆珠笔迹的刻痕： + '5' (18) 65 ？ 我决定不再多想。 我们回到大厅。 “找到了吗？” 五反田（Gotanda）问道。工藤摇头。 “已经十二点了，” 高桥（Takahashi）道。“要不先吃饭吧。” 餐桌上的气氛非常肃穆。大家都默默吃着，seldom next 的两个人小声低语。时川到底去了哪里呢？ 这时，店员端来了两面金黄的油炸哥布林。十数双筷子顿时一齐扑了过去。我没有动。 “天一…… 不来一块？” 新见狼吞虎咽地吃着。 “奇怪，” 我喃喃道，“总觉得有什么不对。” “哪里不对了？我告诉你，完整的哥布林可是稀世珍品，难不成你想吃被滚木碾过一遍的？” 他自谓幽默地笑笑，“快点吧，凉了就不好吃了。” 我取下一片，仔细检查一番；没有 clue。看来我的第六感最近也变得不准了啊，我苦笑着夹起放入嘴中。 —— 我呸呸几口吐了出来。“哥布林有毒！” 旁边的人惊诧地看了我一眼，随即也下意识地做了。 “什么？…… 有毒？” “我们吃着什么事都没有呵…… 哪里有毒了？” 但我既不要无谓的辩解了。循着水木（Mizuki）惊惧的目光，工藤满口白沫地倒在了桌上，一下最后的抽搐。 「端口Ｉ」 警察匆忙赶到现场。 “初步判断死者应该是死鱼（Diefish）氰化物中毒，” 法医汇报道，“不过具体原因还要等解剖结果。” 他点点头。 警察和服务员简单地交谈了几句，走了。房间里笼罩着一团滞重的沉默。 “S 失踪了，Q 死了，” 我自言自语道，“下一个就是我了。” 「DNS错误！」 然而这个世界已不存在规则了。 「Loading . . .」 “好嗨哟！” 有人在我耳边喊道。 “嗨ニマ啊，要动手赶快！” 我不满道。 “好的好的，” 那人说着掏出一卷绳子。“我打算勒死你。不过分吧？” “能换个更舒服的吗？这个绳子勒着好疼。” 我问道。 他摇了摇头。“恐怕没有机会了。” “喂！” 已经喘不过气的我奋力嚷道。“剧本可不是这么写的！” “我知道，” 他平静地说。“你还有什么要说的吗？” “你……” 我很生气。 我边生气边想着明天早上吃什么。 「你们家的网炸了？」 “江户川先生昨天晚上被人不改剧本就弄死了。” 我悲伤地告诉了另外的几个人。 大家都非常惋惜。 「460？再见」 两个月后。 我和高桥，新见，五反田四个人准时上了火车。 “出口竟然没被堵死，” 我对新见说道。 “是啊；话说也真是的，十二个人最后就剩下了四个，连盘身份局都凑不齐…… 真是无聊。” 新见摇头。 “对了，马三傻是怎么死的来着？” 五反田（他似乎一直对这件事念念不忘）第 9102 次问道。 “唉，只有他死的最惨啊。你说是不是？” 新见满脸泪光地笑了起来。 “没有办法……” 我鼻子一酸。“他那天本来想去地沟弄点早点吃，结果刚一出门就让火车给撞死了……” 我不由自主地哭了起来；高桥，新见，五反田也不甘示弱，一瞬间，整个车厢里哀嚎声，哭声，抽泣声，抹泪声揉作一团，是一浪高过一浪，过了好久，车厢里还回荡着一股海风的味道。 “三谷被人用诺基亚砸死了；R 上电梯时被从后面推了一下，掉到电梯井里摔死了；Y ……” 五反田回忆道。 “对了，” 高桥突然叫道，“还记得时川吗？” “他可能永远都不会回来了。” 我推开窗。 “为什么？” 新见问道。只听得五反田似有似无的抽泣声。 “他去了另一个地方。” 半晌，我长吁一口气。“一个更值得的 occasion。” “比我们要去的这个地方更值得？” 高桥问道。我用力点了点头。 之后的很长一段时间里没有人说话。 我久久地望向窗外。又是在这不经意的一刹，透过窗玻璃的反光，高桥指着我，对着正要说出什么惊天秘密似的新见使了个眼色。 我叹了口气。他们果然早已知道了一切。我所为之付的一番心血，并诩诩然以为天衣无缝的计划，不过是跳梁小丑罢了；一切都发生在那么短短的，不到十秒的时间里，可对我来说却像极了一生。 我的视线依然投在远方。看着看着，我渐渐不明白有多少东西可以称得上是变化了。世界本来就没有形状。 我想说些什么，但终究说不出口。我便一直是个如此懦弱的人。 即使是踏上这辆撞死了马三傻的火车。 “还有多长时间到？” 高桥看了看手表。 “很快，” 我答道。 “诶我突然有个想法，” 五反田打起精神，“如果我们到站了还不下车，那么它会载我们到哪里？” “向前。” “Forever?” “Yes.” “可是…… 是你创造了这一切吧？” 我默然。新见好像打开了「神奇动物园」。 “Give him a rest 吧，” 高桥说，“那些事不必再提了。” 我出神地望着车厢的一点。 “吱 ——” 传来汽笛的轰鸣声。 “我们到了，” 新见说。 太阳钻了出来。一阵熹微，暖融融地照在我们的脸上。 “I say . . . 我们应该给自己取个新名字吧？” 五反田提议道，“毕竟西湖六月初嘛。我呢，就叫 MRC 好了。” “我叫大辣鸡。” 新见若有所思道。 “我叫大肥猪。” 高桥毫不犹豫地说出了自己的心声。 “所以…… 你呢？” 所有人的目光望向我。我惊了一下，笑容凝结在脸上。就在那边。 我眨了眨眼；一切如故。 原来我们是到了这里啊，我想道。不过也无所谓了。 新见和五反田 paradox 地对视着。 “天一有事吗……” 高桥迟疑了一下，问道。 “没事没事，” 我摆摆手，“刚才想事来着。” 太阳沉了下去。最初的一道光。 “高桥？” 我唤道。她侧过脸。 “怎么啦？” “早晨来临了。” （BGM : ノルウェイの森） （WOW） （&lt;・)))&gt;&lt;&lt;）","categories":[{"name":"小说 & 随笔","slug":"hitokoto","permalink":"https://snow.js.org/categories/hitokoto/"},{"name":"未来","slug":"hitokoto/future","permalink":"https://snow.js.org/categories/hitokoto/future/"}],"tags":[{"name":"小说","slug":"小说","permalink":"https://snow.js.org/tags/%E5%B0%8F%E8%AF%B4/"}]}],"categories":[{"name":"小说 & 随笔","slug":"hitokoto","permalink":"https://snow.js.org/categories/hitokoto/"},{"name":"算法","slug":"algorithm","permalink":"https://snow.js.org/categories/algorithm/"},{"name":"未来","slug":"hitokoto/future","permalink":"https://snow.js.org/categories/hitokoto/future/"},{"name":"动态规划","slug":"algorithm/dp","permalink":"https://snow.js.org/categories/algorithm/dp/"},{"name":"Hexo","slug":"hexo","permalink":"https://snow.js.org/categories/hexo/"},{"name":"陌上","slug":"hitokoto/陌上","permalink":"https://snow.js.org/categories/hitokoto/%E9%99%8C%E4%B8%8A/"},{"name":"网络流","slug":"algorithm/network-flow","permalink":"https://snow.js.org/categories/algorithm/network-flow/"}],"tags":[{"name":"游记","slug":"游记","permalink":"https://snow.js.org/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"算法","slug":"算法","permalink":"https://snow.js.org/tags/%E7%AE%97%E6%B3%95/"},{"name":"数论","slug":"数论","permalink":"https://snow.js.org/tags/%E6%95%B0%E8%AE%BA/"},{"name":"图论","slug":"图论","permalink":"https://snow.js.org/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"LCA","slug":"lca","permalink":"https://snow.js.org/tags/lca/"},{"name":"小说","slug":"小说","permalink":"https://snow.js.org/tags/%E5%B0%8F%E8%AF%B4/"},{"name":"DAG","slug":"dag","permalink":"https://snow.js.org/tags/dag/"},{"name":"DFS","slug":"dfs","permalink":"https://snow.js.org/tags/dfs/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://snow.js.org/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"DP","slug":"dp","permalink":"https://snow.js.org/tags/dp/"},{"name":"树","slug":"树","permalink":"https://snow.js.org/tags/%E6%A0%91/"},{"name":"Hexo","slug":"hexo","permalink":"https://snow.js.org/tags/hexo/"},{"name":"Butterfly","slug":"butterfly","permalink":"https://snow.js.org/tags/butterfly/"},{"name":"Aplayer","slug":"aplayer","permalink":"https://snow.js.org/tags/aplayer/"},{"name":"博客","slug":"博客","permalink":"https://snow.js.org/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"排序","slug":"排序","permalink":"https://snow.js.org/tags/%E6%8E%92%E5%BA%8F/"},{"name":"STL","slug":"stl","permalink":"https://snow.js.org/tags/stl/"},{"name":"部署","slug":"部署","permalink":"https://snow.js.org/tags/%E9%83%A8%E7%BD%B2/"},{"name":"Vercel","slug":"vercel","permalink":"https://snow.js.org/tags/vercel/"},{"name":"Gulp","slug":"gulp","permalink":"https://snow.js.org/tags/gulp/"},{"name":"PWA","slug":"pwa","permalink":"https://snow.js.org/tags/pwa/"},{"name":"应用程序","slug":"应用程序","permalink":"https://snow.js.org/tags/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"name":"最短路","slug":"最短路","permalink":"https://snow.js.org/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"SSH","slug":"ssh","permalink":"https://snow.js.org/tags/ssh/"},{"name":"GitHub","slug":"github","permalink":"https://snow.js.org/tags/github/"},{"name":"PB_DS","slug":"pb-ds","permalink":"https://snow.js.org/tags/pb-ds/"},{"name":"网络流","slug":"网络流","permalink":"https://snow.js.org/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"最小割","slug":"最小割","permalink":"https://snow.js.org/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"},{"name":"二分图","slug":"二分图","permalink":"https://snow.js.org/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"匹配","slug":"匹配","permalink":"https://snow.js.org/tags/%E5%8C%B9%E9%85%8D/"},{"name":"随笔","slug":"随笔","permalink":"https://snow.js.org/tags/%E9%9A%8F%E7%AC%94/"},{"name":"单调队列","slug":"单调队列","permalink":"https://snow.js.org/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"尺取法","slug":"尺取法","permalink":"https://snow.js.org/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"},{"name":"双指针","slug":"双指针","permalink":"https://snow.js.org/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"码风","slug":"码风","permalink":"https://snow.js.org/tags/%E7%A0%81%E9%A3%8E/"},{"name":"数据结构","slug":"数据结构","permalink":"https://snow.js.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"平衡树","slug":"平衡树","permalink":"https://snow.js.org/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"}]}